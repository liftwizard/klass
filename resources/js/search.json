[[{"l":"Part1"},{"l":"Scope","p":["This document covers long-term vision. A shorter-term, minimal-viable-product is discussed here.","This covers one set of implementation choices. Alternatives are discussed here.","Business value, rationale, justification are discussed here.","Related works are discussed here.","Internal design is discussed here."]},{"l":"Running example","p":["To demonstrate the framework's capabilities, we will walk through building a realistic subset of Stack Overflow functionality."]},{"l":"Getting started","p":["First, run the maven archetype.","This command creates a new project in ./stackoverflow/. The project compiles and runs, but doesn't yet do anything interesting."]},{"l":"Model","p":["The model was generated in ./stackoverflow/stackoverflow-domain-model/src/main/resources/com/stackoverflow/stackoverflow.klass. It is nearly empty except for the package declaration.","An Klass model consists of classes, enumerations, associations, projections, and services.","The classes, enumerations, and associations make up the data model. From the data model, Klass generates a database schema, POJOs, DTOs, example data, etc. We will define the Question and Answer classes, as well as the one-to-many association between questions and answers.","Services are traditional http or rpc services. We will define a service to get a Question by its id.","Projections map services to data. They answer how much data a service reads or writes; conceptually how far the service walks through the object graph. For example, when we fetch a Question by its id, should we return the title and the body, or just the title? Should we include the question's answers in the response?"]}],[{"l":"1 classes"},{"l":"Classes","p":["Let's add the classes Question and Answer to the model in stackoverflow.klass."]},{"l":"Question","p":["id has the primitive type Long. The key modifier is similar to a database's primary key. The id modifier on the id property means that it's an auto-incrementing number, not a natural key.","title has the primitive type String with max length 150.","body has the primitive type String with max length 30000.","So far, this exactly matches the real Stack Overflow."]},{"l":"Answer","p":["Answer also has id and body but no title.","Answer has questionId with the private modifier. It's private to the data-layer; it will be used as a foreign key. Private properties cannot appear in projections, so questionId won't be part of service bodies; neither request bodies nor response bodies."]}],[{"l":"2 associations"},{"l":"Associations","p":["Let's add the one-to-many association between questions and answers.","Associations have two ends, and a direction.","The source end is named question and has type Question. The lower-bound of the multiplicity is 1 and the upper bound is also 1.","The target end is named answers and has type Answer. The lower-bound of the multiplicity is 0 and the upper bound is * which means \"many\".","Question[1..1] means that every answer requires a question. An optional, or nullable property has the multiplicity [0..1]. The syntax [1] is shorthand for [1..1].","Answer[0..*] means that every question has many answers, and that the set of answers is allowed to be empty. A non-empty set has the multiplicity [1..*]. The syntax [*] is shorthand for [0..*].","Colloquially, we call this a one-to-many relationship. Keep in mind that this shorthand is vague. It only refers to the upper-bounds of the association ends.","Klass doesn't enforce singular and plural names. Take care to use singular names for to-one ends and plural names for to-many ends.","The question end has the modifier final which means that an answer cannot be repointed to a different question. In the data layer, this means the foreign key questionId is immutable. It doesn't mean that the question's text is immutable."]}],[{"l":"3 projections and services"},{"l":"Projections and Services","p":["Let's add the service to fetch a question by its id."]},{"l":"Service","p":["Read operations translate to the GET verb when using http.","We'll be able to GET/api/question/1 to fetch the Question with id 1.","The response will be json.","The return multiplicity is one, so the response body will be a json object, not a json array.","The criteria matches Question.id against the path parameter questionId, like the sql where q.id = ?","The projection defines how much data will get serialized in the response body."]},{"l":"Projection","p":["The service referred to the projection QuestionReadProjection without defining it. Let's do that now.","This projection includes everything; all of the question's properties including its answers, and all of the answers' properties. We do want everything included in the service's json response, but if we didn't we could remove parts to shrink the response."]},{"l":"JSON Format","p":["Since the service definition includes format: json, the response body will match the nested structure of the projection, and the projection's header names will be ignored."]},{"l":"CSV Format","p":["If the service definition included format: csv instead, then the nested structure would be flattened and the header names would become column headers in the response. The order of the columns would be defined by the order they appear in the projection definition from top-to-bottom, which is depth-first.","Note that to-many association ends get flattened, so the data for question 1 appears twice."]}],[{"l":"Audit Data","p":["So far, we've built a simple read service. We could add create, update, and delete and we'd have a \"simple crud\" version of Stack Overflow. But the real Stack Overflow services are more advanced. All updates and deletes are non-destructive. When you edit a question or answer, you can still view all of its old versions."]},{"l":"Versions","p":["Here's a real example from Stack Overflow. The answer has 3 versions, at the time of writing. The url returns the latest version. There's a link with text like \"edited Apr 20 at 10:10\" which you can follow to see all versions. Each version has a number, a timestamp, the author's username, and the full text of the answer at the time."]},{"l":"Optimistic locking","p":["Imagine that two users click Edit at the same time, make changes, and click \"Save Edits\". Without a carefully designed api, whoever saves second could silently overwrite the changes of the first. Stack Overflow uses version numbers to implement optimistic locking. Each mutating service takes the edited text, plus the version number that the edit applies to. In this example, the second user would get an error message saying something about attempting to edit version 3, while the current version is 4. They'd then have an opportunity to view the new edits and retry against the new version."]},{"l":"Audit features","p":["Klass treats these as separate features, which build upon each other.","Temporal milestoning makes edits non-destructive, and adds the active time ranges to each piece of data.","Versioning adds simple version numbers (1, 2, 3, ...) to each active time range. Versioned data must be temporally milestoned.","Auditing adds tracking of the created-by author, last-updated-by author, and created-on time. Audited data must be temporally milestoned.","Optimistic locking enhances \"mutating\" services to expect a version parameter, and to fail with a helpful error message on stale versions. Optimistically locked data must be versioned."]}],[{"l":"1 audit model"},{"l":"Audit Model","p":["All four features are activated using classifier modifiers.","Most classifier modifiers are compiler macros that are shorthand for a longer syntax that you could write out if desired."]},{"l":"systemTemporal","p":["The modifier systemTemporal is shorthand for adding three properties.","systemFrom and systemTo become part of the data layer. system is a synthetic property used in queries and criteria.","Relationships between two systemTemporal classes also implicitly include an equality clause between their system properties."]},{"l":"versioned","p":["The modifier versioned is shorthand for adding a new version class and an association to it."]},{"l":"audited","p":["Auditing means keeping track of who made which modifications. To use auditing, there must be a user class. There may only be a single user class in the model.","The modifier audited is shorthand for adding three properties and two parameterized properties. If the class is versioned, the version class gets the same properties. See the section on composite writes to learn why."]}],[{"l":"2 audited services"},{"l":"Audited Services","p":["Stack Overflow allows collaborative editing. Let's walk through an example where Alice creates a new question and Bob edits the text. Since all audit features are on, both versions of the question are retained and can be fetched through services."]},{"l":"Create","p":["Alice POSTs a new question to /api/question on December 31.","She gets back 201 Created and a location header Location: http://.../api/question/1.","She can GET http://.../api/question/1 to get the full body.","id was set to 1. The next created question will be 2. The next Answer will be 1. Each type gets its own sequence.","systemFrom was set to December 31. systemTo is null, indicating that there is no phase-out time; that this data is currently active.","createdOn matches systemFrom for now.","createdById matches lastUpdatedById for now.","The audit properties appear duplicated on the version. This explained later in composite writes."]},{"l":"Update","p":["Bob PUTs a new version to /api/question/1 the next day, on January 1.","The version number is present and matches, so the edit succeeds. He gets back 204 No Content.","He can GET http://.../api/question/1 to get the full body.","systemFrom was set to January 1. systemTo is null again.","Version 1 (which we'll look at next) had its systemTo updated to the same time, January 1.","The version number was updated to 2.","lastUpdatedById was updated to Bob.","createdById and createdOn are unchanged."]},{"l":"Read by version","p":["To read old versions, we can enhance the read service with an optional version parameter and an optional criteria.","Leaving off the version query parameter would give the latest version. But now we can GET http://.../api/question/1?version=1 to see the previous version.","Everything is identical as when Alice first created it, except for systemTo. It started as null and was changed to January 1, the time version 2 was created.","systemTemporal turns the data store into an immutable append-only log. The only in-place updates are to systemTo and the only possible edit is to phase out a version (by changing systemTo from null to the current instant) while simultaneously phasing in a new version at the same instant. Or, in the case of a delete, not phasing in any new version."]},{"l":"Read by time","p":["While it's usually more convenient to deal with version numbers, we can also query for old versions by time.","Now we can GET http://.../api/question/1?system=2018-01-01T00:00:00.000Z to see the previous version.","Time ranges are inclusive on the from end and exclusive on the to end. So any time within the range [2017-12-31T23:59:59.000Z, 2018-01-01T23:59:59.000Z) would return the first version.","The time range check is fairly complex at the data layer. If we're querying for the current version (the system parameter is not provided or is null) then we have to check that systemTo is also null. Otherwise we have to check that the system parameter falls between systemFrom and systemTo, also taking into account the fact that systemTo may be null. We could have defined the additional criteria like this:","The synthetic property system exists to simplify criteria like this, and to use in association criteria as described in Audit Model. Thus we're able to simplify the optionalCriteria to just this.system == system."]}],[{"l":"Bootstrapped Metamodel","p":["Klass has a metamodel; a model of models. In fact, it has several representations of the same metamodel.","The Abstract Syntax Tree used internally by the compiler.","The in-memory DomainModel object returned upon successful compilation.","The bootstrapped metamodel.","etc.","The bootstrapped metamodel is expressed like a regular model. The first few meta-types are defined like this:","The full source is too large to include here. It defines enumeration, class, association, projection, and service, plus their parts.","The bootstrapped metamodel allows us to work with metadata like regular data. It defines some projections and services which return model data. For example, here's the service to get a class by its name:"]}],[{"l":"1 bootstrapped model data"},{"l":"Bootstrapped Model Data","p":["The Klass metamodel is part of every Klass model. When a Klass application starts, it \"bootstraps\" the metamodel by populating model data into the data store. This means that in the Stack Overflow application, we can GET /api/meta/class/Question to get the Question class as data."]}],[{"l":"2 bootstrapped meta model data"},{"l":"Bootstrapped Metamodel Data","p":["Since the metamodel is part of the model, the bootstrap process populates metamodel types too. This means that we can GET /api/meta/class/Klass for the Klass class in any application."]}],[{"l":"3 dynamic query"},{"l":"Dynamic Query","p":["In a production application, we only enable modeled services. In development, it can be useful to allow dynamic queries.","The dynamic query endpoint is a service that accepts a dynamic projection and criteria as a request body. The format is very similar to the serialized form of a projection or service from the bootstrapped metamodel.","Say we wanted to query for all questions that start with the words \"Why do\". We could POST /api/meta/query/json:","There's also a form that uses GET, to allow easier experimentation from the browser. The same query can be encoded as query parameters.","/api/meta/query/json/Question?multiplicity=manycriteria=this.title startsWith Why doinclude=this.title","If there's an existing projection that you want to reuse, you can just refer to it by name."]}],[{"l":"4 dynamic ui"},{"l":"Dynamic UI","p":["Production UI components are code-generated, but the dynamic UI used in development is static JavaScript.","The UI fetches the domain model from the meta-services. It renders dynamic forms for querying and editing based on classes and their data-type properties.","The dynamic projection builder uses classes and all their properties, including association ends. The root node represents a class. Leaf nodes are data-type properties or association ends that are not included in the projection. Inner nodes are association ends that are included in the projection."]}],[{"l":"5 dynamic model"},{"l":"Dynamic Model","p":["We can fetch the bootstrapped model with a GET against the /api/meta services. For projections and services only, we can also create new ones by POSTing to the same urls."]}],[{"l":"Additional Features","p":["In this section, we'll continue the Stack Overflow example and implement up/down votes on Questions.","We'll explore enumerations, parameterized properties, parameterized projections, and aggregations."]},{"l":"Enumerations","p":["We'll start with an enumeration to indicate the direction of a vote.","The upper-case literal names are used within the model. The quoted strings are pretty names that will appear in service request and response bodies."]},{"i":"partial-inference-composite-keys","l":"Partial inference, composite keys","p":["Next we'll define the vote class.","Stack Overflow restricts voting based on how many times you've voted and whether the post was edited since the last vote. So votes must be systemTemporal.","Votes must be audited, to keep track of who cast the vote.","A user can only cast one vote, so the key should be (questionId, createdById). There is no auto-generated id property. QuestionVote has a natural, composite key.","Normally, we'd allow the createdById property to be inferred based on the audited keyword, but then it would be inferred without the key modifier.","A user cannot upvote and downvote the same question, so direction is not part of the key."]},{"l":"Associations","p":["A vote is like many-to-many mapping from Question to User."]},{"l":"Services","p":["We'll create an upsert service for creating and editing votes. No create service is necessary because there's no auto-incrementing id.","The main criteria uses the global userId which is the name of the currently logged in principal.","The validation criteria uses the global now, less 5 minutes in milliseconds, to check whether the vote was created within the last 5 minutes.","The DELETE service is very similar. It just doesn't need to validate that the vote exists, and it doesn't need to validate that the voter and the question author are different users."]},{"l":"Parameterized properties","p":["When viewing a question on Stack Overflow, you can see your own vote if you've cast one.","We add myVote() as a parameterized property, though there are no parameters in this example. This criteria is another example using the global userId. Once the parameterized property is defined, it can be included in a projection using the same syntax as an association end. In fact, a parameterized property without any parameters can be thought of as a uni-directional association."]},{"l":"Parameterized projections","p":["The definition of myVote() above is fine, and fairly similar to the upvoted and downvoted properties in the real StackOverflow api.","However, let's add some perhaps unrealistic variants that take parameters, just to see what parameterized properties can do.","Parameterized properties can be included in read projections. There are two ways to provide the parameter, as a constant or as a projection parameter.","Here we define a projection that parameterizes votesByDirection twice, once for each VoteDirection.","Here we define a parameterized projection, that passes its parameter through to voteByUser."]},{"l":"Parameterized service","p":["When using a parameterized projection, the service must also be parameterized."]},{"l":"Parameterized responses","p":["When a json response includes parameterized properties, the parameters become part of the field names."]},{"l":"Aggregations","p":["StackOverflow's documentation states:","Voting scores, as displayed, are the sum of the up and down votes on a post. Vote counts are the individual up and down votes that make up the score.","You can view the vote counts by clicking on the score of a post. This will break the score into upvotes and downvotes.","We add two aggregation properties to Question; upvotes and downvotes.","Associations and parameterized properties are defined using criteria. Aggregation properties are defined using a fuller expression language. These aggregations use the count() function. Other available functions include sum(), min(), max(), and average().","Once these aggregation properties are defined in a class, they can be included in read projections like normal properties. They cannot be included in write projections."]}],[{"l":"Alternative implementation choices"},{"l":"One-time generation","p":["Instead of a maven archetype, initial project creation could be done with:","Yeoman.","A webapp that produces a zip for download, like Spring Initializr for Spring Boot.","A custom CLI, possibly in python."]},{"l":"Metamodel","p":["Instead of a new metamodel, Klass could use an existing metamodel like Eclipse Modeling Framework's ECore.","ECore is a fairly complete implementation of UML, with all its warts. ECore also has enhancements to allow it to represent anything expressible in Java, including Generics.","Klass's metamodel is a fairly narrow subset of UML. It addresses some weaknesses in UML, such as the lack of a type hierarchy between the various types of properties.","Klass's metamodel also includes projections and services."]},{"l":"Metamodel language","p":["Instead of a new DSL, the model could be expressed using:","OpenAPI vendor extensions(maybe, unproven)","A data format that's not a DSL, like JSON, YML, or XML, conforming to a JSON schema or XSD.","Annotations inside a Java or Python program.","A graphical language like UML."]},{"l":"Data Store","p":["Rather than a relational database, the data could be stored in:","A specific non-relational store, like a documentation database or a graph database.","An abstract DataStore interface, with multiple implementations."]},{"l":"Audit Data","p":["Rather than storing phased-out data in the same tables as active data, they could be stored in separate audit tables.","This would improve the performance of queries for active data. It would complicate querying for previous versions, especially when those versions have relationships to data that is still active."]},{"l":"Relationship criteria","p":["The docs show a syntax for relationship criteria that is similar to a sql join.","It's possible to use a syntax where a property is annotated as a foreign key instead.","It's possible to use a syntax where a foreign key tuple is listed instead.","However, parameterized properties would need a more powerful syntax."]},{"l":"Service syntax","p":["The service syntax is url-centric. If we want to support both http and rpc, we may want a more flexible syntax."]}],[{"l":"Related Works"},{"l":"Data mapping aggregators","p":["Examples:","Spark Catalyst / Spark SQL","Hive","In Klass, the model, store, and mapping are all 1-1-1. These tools allow non-trivial mappings between the model and the store.","Model: Clean domain model","Store: A model still, but of the data store. Can be messy.","Mapping: Which tables, columns, etc. map to which part of the clean model. How to perform joins, aggregations.","Systems that support non-trivial mappings tend to be read-only. The mappings are lossy transformations. For example, not every column may be mapped into the model. Or a property may be the result of an aggregation. So there's no obvious way to write through the model.","These systems are powerful analytical tools. Catalyst is a powerful query engine, with advanced planning and routing.","Read-write systems can't support complex mappings, but can rely on the data store for efficient query execution."]},{"l":"OpenAPI"},{"l":"Things to like","p":["SwaggerHub is a site for \"Hosted, Interactive API Documentation\".","It's a great resource for developers to find and use a documented api.","You could imagine it as the foundation for a service discovery mechanism."]},{"l":"Drawbacks","p":["Bidirectional relationships are critical at the data layer, to know that a single foreign key questionId is used to perform the same join when navigating the relationship in either direction.","Exception handling isn't done in Jersey's idiomatic way.","It cannot represent data layer concerns like keys, foreign keys, joins. It doesn't help with fetching data and serializing it to json.","It cannot represent other service types like gRPC without vendor extensions.","It cannot represent UI concerns like display names.","It includes implementation details like numeric http codes.","Loose ecosystem of tools of varying quality.","Minor releases have produced breaking changes in both the code and the http api.","Relationships are uni-directional.","Serializer plugins aren't done in Jersey's idiomatic way.","So a Question has answers, and Answer has a question, but nothing in the schema links these two properties.","Some of the issues above, like breaking changes, were mentioned in the rationale.","The community's top contributors created a hostile fork called openapi-generator.","The Jersey 2 generator, which is the most popular http variant for Java, has quality problems.","The OpenAPI model is tightly bound to http.","The OpenAPI specification and core tools like the Swagger editor are maintained by core contributors.","The various code generators for different technologies have different maintainers and varying quality.","This is fine for json; and after all OpenAPI doesn't help you at the data layer."]},{"i":"spring-boot--jhipster","l":"Spring Boot / JHipster","p":["Spring Boot builds on top of Spring. JHipster builds on top of Spring Boot.","The Spring Boot stack is probably the most spiritually similar related work. There's plenty to like about it, and some drawbacks that may justify not using it."]},{"i":"things-to-like-1","l":"Things to like","p":["JHipster includes JDL, a spiritually similar DSL.","JDL-Studio is a web-based IDE with syntax-highlighting and live-updating read-only UML diagrams.","Relationships in JDL are bidirectional.","Relationships can be annotated with a display field, which is \"the name of the field that should show up in select boxes.\" For example, in an auto-generated form to create Answers, there may be a select box for which Question it answers. It should display title, rather than id.","Spring Data supports many data stores."]},{"i":"drawbacks-1","l":"Drawbacks","p":["Every entity (class) gets an id property, which is an auto-incrementing integer. There are no natural keys.","Spring Data has limited support for audit-data. It can track the version number, last updated time, and last updated user. However, all previous versions are lost.","Hibernate Envers is an extension that is meant to be non-lossy. However:","Envers is not integrated into Spring Boot / JHipster","Envers keeps audit data in separate audit tables with a completely different schema. It is difficult to recreate previous state of anything other than a single vertex in isolation.","Envers adds audit functionality, but doesn't disable Hibernate's destructive. You have to remember not to call update() and delete()."]},{"l":"GraphQL","p":["GraphQL is a query language for APIs. The ecosystem of frameworks that have developed around it can be considered related work.","GraphQL's query language is probably the closest thing in open source to Klass's projections."]},{"i":"things-to-like-2","l":"Things to like","p":["GraphQL's query fields are similar to Klass's read projections.","The nested structure exactly matches the structure of the returned json.","Fields can take arguments.","This is another term for parameterized properties.","This is a powerful technique for refining relationships.","For example, we can refine the relationship between Question and Answer by declaring a field for a Question's answers by some user."]},{"i":"drawbacks-2","l":"Drawbacks","p":["GraphQL's relationships are uni-directional. So a Question has answers, and Answer has a question, but nothing in the schema links these two properties. This is fine for reads; and after all GraphQL started as just a query language. Bidirectional relationships are critical for writes. This is one reason why dgraph's query language is GraphQL+-, which extends edge declarations with a reverse edge.","GraphQL makes it easy to express powerful queries for which there is no efficient execution plan.","For example, a multi-hop graph walk with predicates that narrow the walk on each hop.","The only possible implementation is to perform IO for every hop.","GraphQL was invented to stitch together microservice responses into a cohesive subgraph. It assumes that a \"foreign key\" in one json response will lead to a GET against another service.","GraphQL's responses are always json. There's no notion of flattening. GraphQL cannot return csv, GraphML, etc.","Mutations feel second class. The mutation bodies conform to a schema, but you're on your own for performing the mutation.","It's common to expose a /graphql/ endpoint over http. While not as dangerous as exposing a /sql/ endpoint, it gives complete control to clients by default. It requires extra effort to handle some cross-cutting concerns like recording meaningful metrics, rate limiting, data-level entitlements, etc."]},{"l":"Other related works","p":["EdgeDB","Relay","dgraph","FOAM Framework","TextUML"]}]]