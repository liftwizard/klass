/*
 * Copyright 2026 Craig Motlin
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cool.klass.generator.reladomo.concrete;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Objects;

import javax.annotation.Nonnull;

import com.google.common.base.CaseFormat;
import cool.klass.model.meta.domain.api.DomainModel;
import cool.klass.model.meta.domain.api.Klass;
import cool.klass.model.meta.domain.api.PrimitiveType;
import cool.klass.model.meta.domain.api.property.PrimitiveProperty;
import cool.klass.model.meta.domain.api.property.Property;
import cool.klass.reladomo.primitive.visitor.PrimitiveToReladomoTypeVisitor;
import cool.klass.reladomo.sample.data.RequiredDataTypePropertyVisitor;
import org.eclipse.collections.api.list.ImmutableList;

public class ReladomoConcreteClassGenerator {

	private final DomainModel domainModel;

	public ReladomoConcreteClassGenerator(DomainModel domainModel) {
		this.domainModel = Objects.requireNonNull(domainModel);
	}

	public void writeConcreteClasses(@Nonnull Path path) {
		for (Klass klass : this.domainModel.getClasses()) {
			String packageName = klass.getPackageName();
			String relativePath = packageName.replaceAll("\\.", "/");
			Path parentPath = path.resolve(relativePath);
			createDirectories(parentPath);

			String fileName = klass.getName() + ".java";
			Path outputPath = parentPath.resolve(fileName);

			if (outputPath.toFile().exists()) {
				continue;
			}

			String sourceCode = this.getSourceCode(klass);
			this.printStringToFile(outputPath, sourceCode);
		}
	}

	private static void createDirectories(Path dir) {
		try {
			Files.createDirectories(dir);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	public String getSourceCode(@Nonnull Klass klass) {
		Objects.requireNonNull(klass);

		String packageName = klass.getPackageName();
		String className = klass.getName();
		ImmutableList<PrimitiveProperty> derivedProperties = klass
			.getProperties()
			.selectInstancesOf(PrimitiveProperty.class)
			.select(Property::isDerived);

		String derivedPropertiesSourceCode = this.getDerivedPropertiesSourceCode(derivedProperties);
		String additionalImports = this.getAdditionalImports(klass, derivedProperties, klass.isTemporal());
		String constructors = this.getConstructors(klass);

		// language=JAVA
		return (
			""
			+ "package "
			+ packageName
			+ ";\n"
			+ additionalImports
			+ "/**\n"
			+ " * Auto-generated by {@link "
			+ this.getClass().getCanonicalName()
			+ "}\n"
			+ " */\n"
			+ "public class "
			+ className
			+ "\n"
			+ "        extends "
			+ className
			+ "Abstract\n"
			+ "        implements ReladomoReadable"
			+ className
			+ "\n"
			+ "{\n"
			+ constructors
			+ derivedPropertiesSourceCode
			+ "}\n"
		);
	}

	private String getConstructors(@Nonnull Klass klass) {
		String className = klass.getName();

		if (klass.isTemporal()) {
			// language=JAVA
			return (
				""
				+ "    public "
				+ className
				+ "(Timestamp system)\n"
				+ "    {\n"
				+ "        super(system);\n"
				+ "        // You must not modify this constructor. Reladomo calls this internally.\n"
				+ "        // You can call this constructor. You can also add new constructors.\n"
				+ "    }\n"
				+ "\n"
				+ "    public "
				+ className
				+ "()\n"
				+ "    {\n"
				+ "        this(UtcInfinityTimestamp.getDefaultInfinity());\n"
				+ "    }\n"
			);
		} else {
			// language=JAVA
			return (
				""
				+ "    public "
				+ className
				+ "()\n"
				+ "    {\n"
				+ "        super();\n"
				+ "        // You must not modify this constructor. Reladomo calls this internally.\n"
				+ "        // You can call this constructor. You can also add new constructors.\n"
				+ "    }\n"
			);
		}
	}

	private String getAdditionalImports(
		@Nonnull Klass klass,
		ImmutableList<PrimitiveProperty> derivedProperties,
		boolean isTemporal
	) {
		StringBuilder imports = new StringBuilder();

		boolean hasLocalDate = derivedProperties.anySatisfy((p) -> p.getType() == PrimitiveType.LOCAL_DATE);
		boolean hasInstant = derivedProperties.anySatisfy((p) -> p.getType() == PrimitiveType.INSTANT);

		// java.sql imports - Timestamp only needed for temporal class constructors (not derived properties)
		if (isTemporal) {
			imports.append("\n");
			imports.append("import java.sql.Timestamp;\n");
		}

		// java.time imports - for derived temporal properties
		if (hasInstant || hasLocalDate) {
			imports.append("\n");
		}
		if (hasInstant) {
			imports.append("import java.time.Instant;\n");
		}
		if (hasLocalDate) {
			imports.append("import java.time.LocalDate;\n");
		}

		// klass imports (only for temporal classes)
		if (isTemporal) {
			imports.append("\n");
			imports.append("import cool.klass.reladomo.utc.infinity.timestamp.UtcInfinityTimestamp;\n");
		}

		// readable interface import
		imports.append("import ");
		imports.append(klass.getPackageName());
		imports.append(".reladomo.readable.ReladomoReadable");
		imports.append(klass.getName());
		imports.append(";\n");

		imports.append("\n");

		return imports.toString();
	}

	private String getDerivedPropertiesSourceCode(ImmutableList<PrimitiveProperty> derivedProperties) {
		return derivedProperties.collect(this::getDerivedPropertySourceCode).makeString("");
	}

	private String getDerivedPropertySourceCode(PrimitiveProperty derivedProperty) {
		String propertyName = CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_CAMEL, derivedProperty.getName());
		PrimitiveType primitiveType = derivedProperty.getType();
		// Derived properties use Java 8 types for temporals since they bypass Reladomo
		String javaReturnType = this.getJavaTypeForDerived(primitiveType);

		RequiredDataTypePropertyVisitor visitor = new RequiredDataTypePropertyVisitor();
		derivedProperty.visit(visitor);
		Object value = visitor.getResult();

		ValueToJavaSourceCodePrimitiveTypeVisitor sourceCodeVisitor = new ValueToJavaSourceCodePrimitiveTypeVisitor(
			value
		);

		primitiveType.visit(sourceCodeVisitor);
		String valueSourceCode = sourceCodeVisitor.getResult();

		// language=JAVA
		return (
			""
			+ "\n"
			+ "    @Override\n"
			+ "    public "
			+ javaReturnType
			+ " get"
			+ propertyName
			+ "()\n"
			+ "    {\n"
			+ "        // TODO implement derived property: "
			+ derivedProperty.getName()
			+ "\n"
			+ "        return "
			+ valueSourceCode
			+ ";\n"
			+ "    }\n"
		);
	}

	private String getJavaTypeForDerived(PrimitiveType primitiveType) {
		// For derived properties, use Java 8 types for temporals but keep primitives for numerics
		return switch (primitiveType) {
			case INSTANT -> "Instant";
			case LOCAL_DATE -> "LocalDate";
			default -> PrimitiveToReladomoTypeVisitor.getJavaType(primitiveType);
		};
	}

	private void printStringToFile(@Nonnull Path path, String contents) {
		try (
			PrintStream printStream = new PrintStream(new FileOutputStream(path.toFile()), true, StandardCharsets.UTF_8)
		) {
			printStream.print(contents);
		} catch (FileNotFoundException e) {
			throw new RuntimeException(e);
		}
	}
}
