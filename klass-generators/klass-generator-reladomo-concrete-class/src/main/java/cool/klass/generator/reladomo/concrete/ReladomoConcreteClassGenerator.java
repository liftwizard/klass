/*
 * Copyright 2025 Craig Motlin
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cool.klass.generator.reladomo.concrete;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Objects;

import javax.annotation.Nonnull;

import com.google.common.base.CaseFormat;
import cool.klass.model.meta.domain.api.DomainModel;
import cool.klass.model.meta.domain.api.Klass;
import cool.klass.model.meta.domain.api.PrimitiveType;
import cool.klass.model.meta.domain.api.property.PrimitiveProperty;
import cool.klass.model.meta.domain.api.property.Property;
import cool.klass.reladomo.primitive.visitor.PrimitiveToReladomoTypeVisitor;
import cool.klass.reladomo.sample.data.RequiredDataTypePropertyVisitor;
import org.eclipse.collections.api.list.ImmutableList;

public class ReladomoConcreteClassGenerator {

    private final DomainModel domainModel;

    public ReladomoConcreteClassGenerator(DomainModel domainModel) {
        this.domainModel = Objects.requireNonNull(domainModel);
    }

    public void writeConcreteClasses(@Nonnull Path path) {
        for (Klass klass : this.domainModel.getClasses()) {
            String packageName = klass.getPackageName();
            String relativePath = packageName.replaceAll("\\.", "/");
            Path parentPath = path.resolve(relativePath);
            createDirectories(parentPath);

            String fileName = klass.getName() + ".java";
            Path outputPath = parentPath.resolve(fileName);

            if (outputPath.toFile().exists()) {
                continue;
            }

            String sourceCode = this.getSourceCode(klass);
            this.printStringToFile(outputPath, sourceCode);
        }
    }

    private static void createDirectories(Path dir) {
        try {
            Files.createDirectories(dir);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public String getSourceCode(@Nonnull Klass klass) {
        Objects.requireNonNull(klass);

        String packageName = klass.getPackageName();
        String className = klass.getName();
        ImmutableList<PrimitiveProperty> primitiveProperties = klass
            .getProperties()
            .selectInstancesOf(PrimitiveProperty.class)
            .select(Property::isDerived);

        String derivedPropertiesSourceCode = this.getDerivedPropertiesSourceCode(primitiveProperties);

        // language=JAVA
        return (
            "" +
            "package " +
            packageName +
            ";\n" +
            "\n" +
            "import java.sql.Timestamp;\n" +
            "\n" +
            "import com.gs.fw.common.mithra.util.DefaultInfinityTimestamp;\n" +
            "import " +
            packageName +
            ".reladomo.readable." +
            className +
            ";\n" +
            "\n" +
            "/**\n" +
            " * Auto-generated by {@link " +
            this.getClass().getCanonicalName() +
            "}\n" +
            " */\n" +
            "public class " +
            className +
            "\n" +
            "        extends " +
            className +
            "Abstract\n" +
            "        implements ReladomoReadable" +
            className +
            "\n" +
            "{\n" +
            "    public " +
            className +
            "(Timestamp system)\n" +
            "    {\n" +
            "        super(system);\n" +
            "        // You must not modify this constructor. Mithra calls this internally.\n" +
            "        // You can call this constructor. You can also add new constructors.\n" +
            "    }\n" +
            "\n" +
            "    public " +
            className +
            "()\n" +
            "    {\n" +
            "        this(DefaultInfinityTimestamp.getDefaultInfinity());\n" +
            "    }\n" +
            derivedPropertiesSourceCode +
            "}\n"
        );
    }

    private String getDerivedPropertiesSourceCode(ImmutableList<PrimitiveProperty> derivedProperties) {
        return derivedProperties.collect(this::getDerivedPropertySourceCode).makeString("");
    }

    private String getDerivedPropertySourceCode(PrimitiveProperty derivedProperty) {
        String propertyName = CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_CAMEL, derivedProperty.getName());
        PrimitiveType primitiveType = derivedProperty.getType();
        String javaReturnType = PrimitiveToReladomoTypeVisitor.getJavaType(primitiveType);

        RequiredDataTypePropertyVisitor visitor = new RequiredDataTypePropertyVisitor();
        derivedProperty.visit(visitor);
        Object value = visitor.getResult();

        ValueToJavaSourceCodePrimitiveTypeVisitor sourceCodeVisitor = new ValueToJavaSourceCodePrimitiveTypeVisitor(
            value
        );

        primitiveType.visit(sourceCodeVisitor);
        String valueSourceCode = sourceCodeVisitor.getResult();

        // language=JAVA
        return (
            "" +
            "\n" +
            "    @Override\n" +
            "    public " +
            javaReturnType +
            " get" +
            propertyName +
            "()\n" +
            "    {\n" +
            "        // TODO implement derived property: " +
            derivedProperty.getName() +
            "\n" +
            "        return " +
            valueSourceCode +
            ";\n" +
            "    }\n"
        );
    }

    private void printStringToFile(@Nonnull Path path, String contents) {
        try (
            PrintStream printStream = new PrintStream(new FileOutputStream(path.toFile()), true, StandardCharsets.UTF_8)
        ) {
            printStream.print(contents);
        } catch (FileNotFoundException e) {
            throw new RuntimeException(e);
        }
    }
}
