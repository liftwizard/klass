package cool.klass.generator.graphql.runtime.wiring.query;

import java.nio.file.Path;

import javax.annotation.Nonnull;

import com.google.common.base.CaseFormat;
import cool.klass.generator.perpackage.AbstractPerPackageGenerator;
import cool.klass.model.meta.domain.api.Classifier;
import cool.klass.model.meta.domain.api.DomainModel;
import cool.klass.model.meta.domain.api.Klass;
import org.atteo.evo.inflector.English;
import org.eclipse.collections.api.list.ImmutableList;
import org.eclipse.collections.api.list.MutableList;
import org.eclipse.collections.impl.list.fixed.ArrayAdapter;

public class GraphQLQueryRuntimeWiringGenerator
        extends AbstractPerPackageGenerator
{
    public GraphQLQueryRuntimeWiringGenerator(@Nonnull DomainModel domainModel)
    {
        super(domainModel);
    }

    @Nonnull
    @Override
    protected Path getPluginRelativePath(Path path)
    {
        return path
                .resolve("graphql")
                .resolve("runtime")
                .resolve("wiring")
                .resolve("query");
    }

    @Nonnull
    @Override
    protected String getFileName()
    {
        return "QueryTypeRuntimeWiringProvider.java";
    }

    @Nonnull
    @Override
    protected String getPackageSourceCode(@Nonnull String fullyQualifiedPackage)
    {
        ImmutableList<Klass> concreteClasses = this.domainModel
                .getClasses()
                .reject(Klass::isAbstract)
                .select(each -> each.getPackageName().equals(fullyQualifiedPackage));

        //language=JAVA
        String sourceCode = ""
                + "package " + fullyQualifiedPackage + ".graphql.runtime.wiring.query;\n"
                + "\n"
                + "import cool.klass.graphql.type.runtime.wiring.provider.GraphQLTypeRuntimeWiringProvider;\n"
                + concreteClasses.collect(this::getFinderImport).makeString("")
                + concreteClasses.collect(this::getAllFetcherImport).makeString("")
                + concreteClasses.collect(this::getKeyFetcherImport).makeString("")
                + "import graphql.schema.idl.TypeRuntimeWiring.Builder;\n"
                + "import io.liftwizard.graphql.reladomo.finder.fetcher.ReladomoFinderDataFetcher;\n"
                + "import io.liftwizard.graphql.reladomo.operation.fetcher.ReladomoOperationDataFetcher;\n"
                + "\n"
                + "/**\n"
                + " * Auto-generated by {@link " + this.getClass().getCanonicalName() + "}\n"
                + " */\n"
                + "public class QueryTypeRuntimeWiringProvider\n"
                + "        implements GraphQLTypeRuntimeWiringProvider\n"
                + "{\n"
                + "    @Override\n"
                + "    public Builder get()\n"
                + "    {\n"
                + "        Builder builder = new Builder();\n"
                + "        builder.typeName(\"Query\");\n"
                + "\n"
                + this.getAllDataFetchersSourceCode(concreteClasses).makeString("")
                + "\n"
                + this.getByKeyDataFetchersSourceCode(concreteClasses).makeString("")
                + "\n"
                + this.getByOperationDataFetchersSourceCode(concreteClasses).makeString("")
                + "\n"
                + this.getByFinderDataFetchersSourceCode(concreteClasses).makeString("")
                + "\n"
                + "        return builder;\n"
                + "    }\n"
                + "}\n";

        return sourceCode;
    }

    private String getFinderImport(Klass klass)
    {
        return "import " + klass.getFullyQualifiedName() + "Finder;\n";
    }

    private String getAllFetcherImport(Klass klass)
    {
        return "import " + klass.getPackageName() + ".graphql.data.fetcher.all.All" + klass.getName() + "DataFetcher;\n";
    }

    private String getKeyFetcherImport(Klass klass)
    {
        return "import " + klass.getPackageName() + ".graphql.data.fetcher.key." + klass.getName() + "ByKeyDataFetcher;\n";
    }

    private ImmutableList<String> getAllDataFetchersSourceCode(ImmutableList<Klass> classes)
    {
        return classes
                .reject(Klass::isAbstract)
                .collect(this::getAllDataFetcherSourceCode);
    }

    private String getAllDataFetcherSourceCode(Classifier classifier)
    {
        return String.format(
                "        builder.dataFetcher(\"%s\", new All%sDataFetcher());\n",
                this.getPropertyName(classifier),
                classifier.getName());
    }

    private String getPropertyName(Classifier classifier)
    {
        String classifierName = classifier.getName();

        String              lowerUnderscore = CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, classifierName);
        MutableList<String> splits          = ArrayAdapter.adapt(lowerUnderscore.split("_"));

        return splits
                .collectWithIndex((eachSplit, index) -> this.capitalizeSplit(eachSplit, index, splits.size()))
                .makeString("");
    }

    private String capitalizeSplit(String eachSplit, int index, int splitsSize)
    {
        return this.getCapitalized(index, this.getPluralized(index, splitsSize, eachSplit));
    }

    private String getPluralized(int index, int splitsSize, String eachSplit)
    {
        return index == splitsSize - 1 ? English.plural(eachSplit) : eachSplit;
    }

    private String getCapitalized(int index, String eachSplit)
    {
        return index != 0
                ? CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, eachSplit)
                : eachSplit;
    }

    private ImmutableList<String> getByKeyDataFetchersSourceCode(ImmutableList<Klass> classes)
    {
        return classes
                .reject(Klass::isAbstract)
                .collect(this::getByKeyDataFetcherSourceCode);
    }

    private ImmutableList<String> getByOperationDataFetchersSourceCode(ImmutableList<Klass> classes)
    {
        return classes
                .reject(Klass::isAbstract)
                .collect(this::getByOperationDataFetcherSourceCode);
    }

    private ImmutableList<String> getByFinderDataFetchersSourceCode(ImmutableList<Klass> classes)
    {
        return classes
                .reject(Klass::isAbstract)
                .collect(this::getByFinderDataFetcherSourceCode);
    }

    private String getByKeyDataFetcherSourceCode(Classifier classifier)
    {
        String classifierName = classifier.getName();
        return String.format(
                "        builder.dataFetcher(\"%s\", new %sByKeyDataFetcher());\n",
                CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, classifierName),
                classifierName);
    }

    private String getByOperationDataFetcherSourceCode(Classifier classifier)
    {
        String classifierName = classifier.getName();
        return String.format(
                "        builder.dataFetcher(\"%sByOperation\", new ReladomoOperationDataFetcher<>(%sFinder.getFinderInstance()));\n",
                CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, classifierName),
                classifierName);
    }

    private String getByFinderDataFetcherSourceCode(Classifier classifier)
    {
        String classifierName = classifier.getName();
        return String.format(
                "        builder.dataFetcher(\"%sByFinder\", new ReladomoFinderDataFetcher<>(%sFinder.getFinderInstance()));\n",
                CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, classifierName),
                classifierName);
    }
}
