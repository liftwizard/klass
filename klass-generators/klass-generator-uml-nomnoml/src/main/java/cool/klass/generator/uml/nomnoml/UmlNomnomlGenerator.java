package cool.klass.generator.uml.nomnoml;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.nio.file.Path;
import java.util.Objects;

import javax.annotation.Nonnull;

import cool.klass.model.meta.domain.api.Association;
import cool.klass.model.meta.domain.api.DomainModel;
import cool.klass.model.meta.domain.api.Enumeration;
import cool.klass.model.meta.domain.api.Interface;
import cool.klass.model.meta.domain.api.Klass;
import cool.klass.model.meta.domain.api.NamedElement;
import cool.klass.model.meta.domain.api.TopLevelElement;
import cool.klass.model.meta.domain.api.TopLevelElementVisitor;
import cool.klass.model.meta.domain.api.modifier.DataTypePropertyModifier;
import cool.klass.model.meta.domain.api.projection.Projection;
import cool.klass.model.meta.domain.api.property.AssociationEnd;
import cool.klass.model.meta.domain.api.property.DataTypeProperty;
import cool.klass.model.meta.domain.api.service.ServiceGroup;
import org.eclipse.collections.api.list.ImmutableList;

public class UmlNomnomlGenerator
{
    @Nonnull
    private final DomainModel domainModel;
    @Nonnull
    private final String      rootPackageName;
    @Nonnull
    private final String      applicationName;

    public UmlNomnomlGenerator(
            @Nonnull DomainModel domainModel,
            @Nonnull String rootPackageName,
            @Nonnull String applicationName)
    {
        this.domainModel     = Objects.requireNonNull(domainModel);
        this.rootPackageName = Objects.requireNonNull(rootPackageName);
        this.applicationName = Objects.requireNonNull(applicationName);
    }

    public void writeUmlDiagram(@Nonnull Path outputPath)
    {
        String topLevelElementsSourceCode = this.domainModel
                .getTopLevelElements()
                .collect(this::getSourceCode)
                .makeString("");

        String sourceCode = ""
                + "// Auto-generated by cool.klass.generator.uml.nomnoml.UmlNomnomlGenerator\n"
                + "\n"
                + topLevelElementsSourceCode;

        Path schemaOutputPath = this.getOutputPath(outputPath);
        this.printStringToFile(schemaOutputPath, sourceCode);
    }

    private String getSourceCode(TopLevelElement packageableElement)
    {
        var visitor = new TopLevelElementSourceCodeVisitor();
        packageableElement.visit(visitor);
        return visitor.getSourceCode();
    }

    @Nonnull
    private Path getOutputPath(@Nonnull Path outputPath)
    {
        String packageRelativePath = this.rootPackageName.replaceAll("\\.", "/");
        Path outputDirectory = outputPath
                .resolve(packageRelativePath)
                .resolve("uml")
                .resolve("nomnoml");
        outputDirectory.toFile().mkdirs();
        String fileName = this.applicationName + ".nomnoml";
        return outputDirectory.resolve(fileName);
    }

    private void printStringToFile(@Nonnull Path path, String contents)
    {
        try (PrintStream printStream = new PrintStream(new FileOutputStream(path.toFile())))
        {
            printStream.print(contents);
        }
        catch (FileNotFoundException e)
        {
            throw new RuntimeException(e);
        }
    }

    private static class TopLevelElementSourceCodeVisitor implements TopLevelElementVisitor
    {
        private String sourceCode;

        private String getSourceCode()
        {
            return this.sourceCode;
        }

        @Override
        public void visitEnumeration(Enumeration enumeration)
        {
            String enumerationLiteralsSourceCode = enumeration
                    .getEnumerationLiterals()
                    .collect(NamedElement::getName)
                    .collect(each -> "     " + each)
                    .makeString(";\n");

            this.sourceCode = ""
                    + "[ < enumeration >\n"
                    + enumeration.getName() + "\n"
                    + "|\n"
                    + enumerationLiteralsSourceCode + "\n"
                    + "]\n"
                    + "\n";
        }

        @Override
        public void visitInterface(Interface anInterface)
        {
            this.visitClassifier(anInterface);
        }

        @Override
        public void visitKlass(Klass klass)
        {
            this.visitClassifier(klass);
        }

        public void visitClassifier(cool.klass.model.meta.domain.api.Classifier classifier)
        {
            String propertiesSourceCode = classifier
                    .getDataTypeProperties()
                    .reject(DataTypeProperty::isPrivate)
                    .reject(DataTypeProperty::isTemporalRange)
                    .collect(this::getPropertySourceCode)
                    .makeString(";\n");

            this.sourceCode = ""
                    + "[ " + classifier.getName() + " |\n"
                    + propertiesSourceCode + "\n"
                    + "]\n"
                    + "\n";
        }

        @Override
        public void visitAssociation(Association association)
        {
            AssociationEnd sourceAssociationEnd = association.getSourceAssociationEnd();
            AssociationEnd targetAssociationEnd = association.getTargetAssociationEnd();

            String sourceClassName = sourceAssociationEnd.getOwningClassifier().getName();
            String targetClassName = targetAssociationEnd.getOwningClassifier().getName();

            String sourceName = sourceAssociationEnd.getName();
            String targetName = targetAssociationEnd.getName();

            String sourceMultiplicity = sourceAssociationEnd.getMultiplicity().getPrettyName();
            String targetMultiplicity = targetAssociationEnd.getMultiplicity().getPrettyName();

            this.sourceCode = String.format(
                    "// %s%n[%s] %s %s - %s %s [%s]%n%n",
                    association.getName(),
                    targetClassName,
                    sourceName,
                    sourceMultiplicity,
                    targetName,
                    targetMultiplicity,
                    sourceClassName);
        }

        @Override
        public void visitProjection(Projection projection)
        {
            this.sourceCode = this.getPlaceholderComment(projection);
        }

        @Override
        public void visitServiceGroup(ServiceGroup serviceGroup)
        {
            this.sourceCode = this.getPlaceholderComment(serviceGroup);
        }

        private  String getPlaceholderComment(TopLevelElement topLevelElement)
        {
            return String.format("// %s %s%n", topLevelElement.getClass().getSimpleName(), topLevelElement.getName());
        }

        private String getPropertySourceCode(DataTypeProperty dataTypeProperty)
        {
            String isOptionalString = dataTypeProperty.isOptional() && !dataTypeProperty.isTemporal() ? "?" : "";
            ImmutableList<DataTypePropertyModifier> relevantModifiers = dataTypeProperty
                    .getPropertyModifiers()
                    .reject(DataTypePropertyModifier::isAudit)
                    .reject(DataTypePropertyModifier::isFrom)
                    .reject(DataTypePropertyModifier::isTo)
                    .reject(DataTypePropertyModifier::isSystem)
                    .reject(DataTypePropertyModifier::isValid);
            String propertyModifiersString = relevantModifiers.isEmpty()
                    ? ""
                    :  relevantModifiers
                            .collect(NamedElement::getName)
                            .makeString(" // ", " ", "");
            return String.format(
                    "%s: %s%s%s",
                    dataTypeProperty.getName(),
                    dataTypeProperty.getType(),
                    isOptionalString,
                    propertyModifiersString);
        }
    }
}
