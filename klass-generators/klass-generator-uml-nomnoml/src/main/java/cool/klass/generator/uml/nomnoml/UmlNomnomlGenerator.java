package cool.klass.generator.uml.nomnoml;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.nio.file.Path;
import java.util.Objects;

import javax.annotation.Nonnull;

import cool.klass.model.meta.domain.api.Association;
import cool.klass.model.meta.domain.api.DomainModel;
import cool.klass.model.meta.domain.api.Enumeration;
import cool.klass.model.meta.domain.api.Klass;
import cool.klass.model.meta.domain.api.NamedElement;
import cool.klass.model.meta.domain.api.PackageableElement;
import cool.klass.model.meta.domain.api.modifier.DataTypePropertyModifier;
import cool.klass.model.meta.domain.api.property.AssociationEnd;
import cool.klass.model.meta.domain.api.property.DataTypeProperty;
import org.eclipse.collections.api.list.ImmutableList;

public class UmlNomnomlGenerator
{
    @Nonnull
    private final DomainModel domainModel;
    @Nonnull
    private final String      rootPackageName;
    @Nonnull
    private final String      applicationName;

    public UmlNomnomlGenerator(
            @Nonnull DomainModel domainModel,
            @Nonnull String rootPackageName,
            @Nonnull String applicationName)
    {
        this.domainModel     = Objects.requireNonNull(domainModel);
        this.rootPackageName = Objects.requireNonNull(rootPackageName);
        this.applicationName = Objects.requireNonNull(applicationName);
    }

    public void writeUmlDiagram(@Nonnull Path outputPath)
    {
        String topLevelElementsSourceCode = this.domainModel
                .getTopLevelElements()
                .collect(this::getSourceCode)
                .makeString("");

        String sourceCode = ""
                + "// Auto-generated by cool.klass.generator.uml.nomnoml.UmlNomnomlGenerator\n"
                + "\n"
                + topLevelElementsSourceCode;

        Path schemaOutputPath = this.getOutputPath(outputPath);
        this.printStringToFile(schemaOutputPath, sourceCode);
    }

    private String getSourceCode(PackageableElement packageableElement)
    {
        if (packageableElement instanceof Enumeration)
        {
            return this.getEnumerationSourceCode((Enumeration) packageableElement);
        }

        if (packageableElement instanceof Klass)
        {
            return this.getClassSourceCode((Klass) packageableElement);
        }

        if (packageableElement instanceof Association)
        {
            return this.getAssociationSourceCode((Association) packageableElement);
        }

        return String.format("// %s %s%n", packageableElement.getClass().getSimpleName(), packageableElement.getName());
    }

    private String getEnumerationSourceCode(Enumeration enumeration)
    {
        String enumerationLiteralsSourceCode = enumeration
                .getEnumerationLiterals()
                .collect(NamedElement::getName)
                .collect(each -> "     " + each)
                .makeString(";\n");

        return ""
                + "[ < enumeration >\n"
                + enumeration.getName() + "\n"
                + "|\n"
                + enumerationLiteralsSourceCode + "\n"
                + "]\n"
                + "\n";
    }

    private String getClassSourceCode(Klass klass)
    {
        String propertiesSourceCode = klass
                .getDataTypeProperties()
                .reject(DataTypeProperty::isPrivate)
                .reject(DataTypeProperty::isTemporalRange)
                .collect(this::getPropertySourceCode)
                .makeString(";\n");

        return ""
                + "[ " + klass.getName() + " |\n"
                + propertiesSourceCode + "\n"
                + "]\n"
                + "\n";
    }

    private String getAssociationSourceCode(Association association)
    {
        AssociationEnd sourceAssociationEnd = association.getSourceAssociationEnd();
        AssociationEnd targetAssociationEnd = association.getTargetAssociationEnd();

        String sourceClassName = sourceAssociationEnd.getOwningClassifier().getName();
        String targetClassName = targetAssociationEnd.getOwningClassifier().getName();

        String sourceName = sourceAssociationEnd.getName();
        String targetName = targetAssociationEnd.getName();

        String sourceMultiplicity = sourceAssociationEnd.getMultiplicity().getPrettyName();
        String targetMultiplicity = targetAssociationEnd.getMultiplicity().getPrettyName();

        return String.format(
                "// %s%n[%s] %s %s - %s %s [%s]%n%n",
                association.getName(),
                targetClassName,
                sourceName,
                sourceMultiplicity,
                targetName,
                targetMultiplicity,
                sourceClassName);
    }

    private String getPropertySourceCode(DataTypeProperty dataTypeProperty)
    {
        String isOptionalString = dataTypeProperty.isOptional() && !dataTypeProperty.isTemporal() ? "?" : "";
        ImmutableList<DataTypePropertyModifier> relevantModifiers = dataTypeProperty
                .getPropertyModifiers()
                .reject(DataTypePropertyModifier::isAudit)
                .reject(DataTypePropertyModifier::isFrom)
                .reject(DataTypePropertyModifier::isTo)
                .reject(DataTypePropertyModifier::isSystem)
                .reject(DataTypePropertyModifier::isValid);
        String propertyModifiersString = relevantModifiers.isEmpty()
                ? ""
                :  relevantModifiers
                        .collect(NamedElement::getName)
                        .makeString(" // ", " ", "");
        return String.format(
                "%s: %s%s%s",
                dataTypeProperty.getName(),
                dataTypeProperty.getType(),
                isOptionalString,
                propertyModifiersString);
    }

    @Nonnull
    private Path getOutputPath(@Nonnull Path outputPath)
    {
        String packageRelativePath = this.rootPackageName.replaceAll("\\.", "/");
        Path outputDirectory = outputPath
                .resolve(packageRelativePath)
                .resolve("uml")
                .resolve("nomnoml");
        outputDirectory.toFile().mkdirs();
        String fileName = this.applicationName + ".nomnoml";
        return outputDirectory.resolve(fileName);
    }

    private void printStringToFile(@Nonnull Path path, String contents)
    {
        try (PrintStream printStream = new PrintStream(new FileOutputStream(path.toFile())))
        {
            printStream.print(contents);
        }
        catch (FileNotFoundException e)
        {
            throw new RuntimeException(e);
        }
    }
}
