/*
 * Copyright 2025 Craig Motlin
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cool.klass.generator.uml.nomnoml;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Path;
import java.util.Objects;

import javax.annotation.Nonnull;

import cool.klass.model.meta.domain.api.Association;
import cool.klass.model.meta.domain.api.Classifier;
import cool.klass.model.meta.domain.api.DomainModel;
import cool.klass.model.meta.domain.api.Enumeration;
import cool.klass.model.meta.domain.api.Interface;
import cool.klass.model.meta.domain.api.Klass;
import cool.klass.model.meta.domain.api.NamedElement;
import cool.klass.model.meta.domain.api.TopLevelElement;
import cool.klass.model.meta.domain.api.TopLevelElementVisitor;
import cool.klass.model.meta.domain.api.modifier.Modifier;
import cool.klass.model.meta.domain.api.projection.Projection;
import cool.klass.model.meta.domain.api.property.AssociationEnd;
import cool.klass.model.meta.domain.api.property.DataTypeProperty;
import cool.klass.model.meta.domain.api.service.ServiceGroup;
import org.eclipse.collections.api.list.ImmutableList;

public class UmlNomnomlGenerator {

    @Nonnull
    private final DomainModel domainModel;

    @Nonnull
    private final String rootPackageName;

    @Nonnull
    private final String applicationName;

    public UmlNomnomlGenerator(
        @Nonnull DomainModel domainModel,
        @Nonnull String rootPackageName,
        @Nonnull String applicationName
    ) {
        this.domainModel = Objects.requireNonNull(domainModel);
        this.rootPackageName = Objects.requireNonNull(rootPackageName);
        this.applicationName = Objects.requireNonNull(applicationName);
    }

    public void writeUmlDiagram(@Nonnull Path outputPath) {
        String topLevelElementsSourceCode = this.domainModel.getTopLevelElements()
            .collect(this::getSourceCode)
            .makeString("");

        String sourceCode =
            "" +
            "// Auto-generated by cool.klass.generator.uml.nomnoml.UmlNomnomlGenerator\n" +
            "\n" +
            topLevelElementsSourceCode;

        Path schemaOutputPath = this.getOutputPath(outputPath);
        this.printStringToFile(schemaOutputPath, sourceCode);
    }

    private String getSourceCode(TopLevelElement packageableElement) {
        var visitor = new TopLevelElementSourceCodeVisitor();
        packageableElement.visit(visitor);
        return visitor.getSourceCode();
    }

    @Nonnull
    private Path getOutputPath(@Nonnull Path outputPath) {
        String packageRelativePath = this.rootPackageName.replaceAll("\\.", "/");
        Path outputDirectory = outputPath.resolve(packageRelativePath).resolve("uml").resolve("nomnoml");
        outputDirectory.toFile().mkdirs();
        String fileName = this.applicationName + ".noml";
        return outputDirectory.resolve(fileName);
    }

    private void printStringToFile(@Nonnull Path path, String contents) {
        try (
            PrintStream printStream = new PrintStream(new FileOutputStream(path.toFile()), true, StandardCharsets.UTF_8)
        ) {
            printStream.print(contents);
        } catch (FileNotFoundException e) {
            throw new RuntimeException(e);
        }
    }

    private static final class TopLevelElementSourceCodeVisitor implements TopLevelElementVisitor {

        private String sourceCode;

        private String getSourceCode() {
            return this.sourceCode;
        }

        @Override
        public void visitEnumeration(Enumeration enumeration) {
            String enumerationLiteralsSourceCode = enumeration
                .getEnumerationLiterals()
                .collect(NamedElement::getName)
                .collect(each -> "     " + each)
                .makeString(";\n");

            this.sourceCode =
                "" +
                "[ < enumeration >\n" +
                enumeration.getName() +
                "\n" +
                "|\n" +
                enumerationLiteralsSourceCode +
                "\n" +
                "]\n" +
                "\n";
        }

        @Override
        public void visitInterface(Interface anInterface) {
            String classGeneralizationSourceCode = "";
            this.sourceCode = this.getClassifierSourceCode(anInterface, classGeneralizationSourceCode);
        }

        @Override
        public void visitKlass(Klass klass) {
            String classGeneralizationSourceCode = this.getClassGeneralizationSourceCode(klass);
            this.sourceCode = this.getClassifierSourceCode(klass, classGeneralizationSourceCode);
        }

        private String getClassifierSourceCode(Classifier classifier, String classGeneralizationSourceCode) {
            String interfaceGeneralizationsSourceCode = this.getInterfaceGeneralizationsSourceCode(classifier);

            String propertiesSourceCode = this.getClassifierPropertiesSourceCode(classifier);

            return (
                "" +
                "[ " +
                classifier.getName() +
                " |\n" +
                propertiesSourceCode +
                "\n" +
                "]\n" +
                interfaceGeneralizationsSourceCode +
                classGeneralizationSourceCode +
                "\n"
            );
        }

        private String getClassGeneralizationSourceCode(Klass klass) {
            return klass
                .getSuperClass()
                .map(superClass -> this.getGeneralizationSourceCode(superClass, klass))
                .orElse("");
        }

        private String getInterfaceGeneralizationsSourceCode(Classifier classifier) {
            return classifier.getInterfaces().collectWith(this::getImplementationSourceCode, classifier).makeString();
        }

        private String getClassifierPropertiesSourceCode(Classifier classifier) {
            return classifier
                .getDataTypeProperties()
                .reject(DataTypeProperty::isPrivate)
                .reject(DataTypeProperty::isTemporalRange)
                .collect(this::getPropertySourceCode)
                .makeString(";\n");
        }

        private String getGeneralizationSourceCode(Klass superClass, Klass klass) {
            return String.format("[%s] -:> [%s]\n", klass.getName(), superClass.getName());
        }

        private String getImplementationSourceCode(Interface anInterface, Classifier classifier) {
            return String.format("[%s] --:> [%s]\n", classifier.getName(), anInterface.getName());
        }

        @Override
        public void visitAssociation(Association association) {
            AssociationEnd sourceAssociationEnd = association.getSourceAssociationEnd();
            AssociationEnd targetAssociationEnd = association.getTargetAssociationEnd();

            String sourceClassName = sourceAssociationEnd.getOwningClassifier().getName();
            String targetClassName = targetAssociationEnd.getOwningClassifier().getName();

            String sourceName = sourceAssociationEnd.getName();
            String targetName = targetAssociationEnd.getName();

            String sourceMultiplicity = sourceAssociationEnd.getMultiplicity().getPrettyName();
            String targetMultiplicity = targetAssociationEnd.getMultiplicity().getPrettyName();

            String arrow = this.getArrow(sourceAssociationEnd, targetAssociationEnd);

            this.sourceCode = String.format(
                "// %s%n[%s] %s %s %s %s %s [%s]%n%n",
                association.getName(),
                targetClassName,
                sourceName,
                sourceMultiplicity,
                arrow,
                targetName,
                targetMultiplicity,
                sourceClassName
            );
        }

        private String getArrow(AssociationEnd sourceAssociationEnd, AssociationEnd targetAssociationEnd) {
            if (targetAssociationEnd.isOwned()) {
                return "+->";
            }

            if (sourceAssociationEnd.isOwned()) {
                return "-+";
            }

            return "->";
        }

        @Override
        public void visitProjection(Projection projection) {
            this.sourceCode = this.getPlaceholderComment(projection);
        }

        @Override
        public void visitServiceGroup(ServiceGroup serviceGroup) {
            this.sourceCode = this.getPlaceholderComment(serviceGroup);
        }

        private String getPlaceholderComment(TopLevelElement topLevelElement) {
            return String.format("// %s %s%n", topLevelElement.getClass().getSimpleName(), topLevelElement.getName());
        }

        private String getPropertySourceCode(DataTypeProperty dataTypeProperty) {
            String isOptionalString = dataTypeProperty.isOptional() && !dataTypeProperty.isTemporal() ? "?" : "";
            ImmutableList<Modifier> relevantModifiers = dataTypeProperty
                .getModifiers()
                .reject(Modifier::isAudit)
                .reject(Modifier::isFrom)
                .reject(Modifier::isTo)
                .reject(Modifier::isSystem)
                .reject(Modifier::isValid);
            String propertyModifiersString = relevantModifiers.isEmpty()
                ? ""
                : relevantModifiers.collect(Modifier::getKeyword).makeString(" // ", " ", "");
            return String.format(
                "%s: %s%s%s",
                dataTypeProperty.getName(),
                dataTypeProperty.getType(),
                isOptionalString,
                propertyModifiersString
            );
        }
    }
}
