package cool.klass.generator.graphql.runtime.wiring;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.nio.file.Path;
import java.util.Objects;

import javax.annotation.Nonnull;

import cool.klass.model.meta.domain.api.Classifier;
import cool.klass.model.meta.domain.api.DomainModel;
import cool.klass.model.meta.domain.api.Klass;
import cool.klass.model.meta.domain.api.PackageableElement;
import cool.klass.model.meta.domain.api.property.Property;
import cool.klass.model.meta.domain.api.property.ReferenceProperty;
import org.eclipse.collections.api.factory.Lists;
import org.eclipse.collections.api.list.ImmutableList;

public class GraphQLTypeRuntimeWiringProviderGenerator
{
    @Nonnull
    private final DomainModel domainModel;

    public GraphQLTypeRuntimeWiringProviderGenerator(@Nonnull DomainModel domainModel)
    {
        this.domainModel = Objects.requireNonNull(domainModel);
    }

    public void writeTypeRuntimeWiringFiles(@Nonnull Path outputPath)
    {
        this.domainModel
                .getClasses()
                .forEachWith(this::writeTypeRuntimeWiringFile, outputPath);
    }

    private void writeTypeRuntimeWiringFile(@Nonnull Klass klass, @Nonnull Path outputPath)
    {
        Path   runtimeWiringOutputPath = this.getRuntimeWiringOutputPath(outputPath, klass);
        String classSourceCode         = this.getTypeRuntimeWiringSourceCode(klass);
        this.printStringToFile(runtimeWiringOutputPath, classSourceCode);
    }

    @Nonnull
    private Path getRuntimeWiringOutputPath(
            @Nonnull Path outputPath,
            @Nonnull PackageableElement packageableElement)
    {
        String packageRelativePath = packageableElement.getPackageName()
                .replaceAll("\\.", "/");
        Path runtimeWiringDirectory = outputPath
                .resolve(packageRelativePath)
                .resolve("graphql")
                .resolve("type")
                .resolve("runtime")
                .resolve("wiring");
        runtimeWiringDirectory.toFile().mkdirs();
        String fileName = packageableElement.getName() + "TypeRuntimeWiringProvider.java";
        return runtimeWiringDirectory.resolve(fileName);
    }

    private void printStringToFile(@Nonnull Path path, String contents)
    {
        try (PrintStream printStream = new PrintStream(new FileOutputStream(path.toFile())))
        {
            printStream.print(contents);
        }
        catch (FileNotFoundException e)
        {
            throw new RuntimeException(e);
        }
    }

    @Nonnull
    private String getTypeRuntimeWiringSourceCode(@Nonnull Klass klass)
    {
        return klass.isAbstract() ? this.getAbstractSourceCode(klass) : this.getConcreteSourceCode(klass);
    }

    private String getAbstractSourceCode(Klass klass)
    {
        ImmutableList<Klass> subClasses = klass.getSubClassChainWithThis();
        ImmutableList<String> imports   = subClasses.collect(each -> "import " + each.getFullyQualifiedName() + ";\n");
        ImmutableList<String> typeResolverClauses   = subClasses.collect(this::getTypeResolverClause);

        // @formatter:off
        //language=JAVA
        String sourceCode = "package " + klass.getPackageName() + ".graphql.type.runtime.wiring;\n"
                + '\n'
                + "import cool.klass.graphql.type.runtime.wiring.provider.GraphQLTypeRuntimeWiringProvider;\n"
                + "import io.liftwizard.reladomo.graphql.data.fetcher.*;\n"
                + "import graphql.TypeResolutionEnvironment;\n"
                + "import graphql.schema.GraphQLObjectType;\n"
                + "import graphql.schema.TypeResolver;\n"
                + "import graphql.schema.idl.TypeRuntimeWiring.Builder;\n"
                + imports.makeString("")
                + '\n'
                + "/**\n"
                + " * Auto-generated by {@link " + this.getClass().getCanonicalName() + "}\n"
                + " */\n"
                + "public class " + klass.getName() + "TypeRuntimeWiringProvider\n"
                + "        implements GraphQLTypeRuntimeWiringProvider\n"
                + "{\n"
                + "    @Override\n"
                + "    public Builder get()\n"
                + "    {\n"
                + "        Builder builder = new Builder();\n"
                + "        builder.typeName(\"" + klass.getName() + "\");\n"
                + "        builder.typeResolver(new TypeResolver()\n"
                + "        {\n"
                + "            @Override\n"
                + "            public GraphQLObjectType getType(TypeResolutionEnvironment env)\n"
                + "            {\n"
                + "                Object javaObject = env.getObject();\n"
                + typeResolverClauses.makeString("")
                + "                throw new AssertionError(\"Unexpected java object type: \" + javaObject.getClass().getName());\n"
                + "            }\n"
                + "        });\n"
                + "        return builder;\n"
                + "    }\n"
                + "}\n";
        // @formatter:on

        return sourceCode;
    }

    private String getTypeResolverClause(Klass subClass)
    {
        return "                if (javaObject instanceof " + subClass.getName() + ")\n"
                + "                {\n"
                + "                    return env.getSchema().getObjectType(\"" + subClass.getName() + "\");\n"
                + "                }\n";
    }

    @Nonnull
    private String getConcreteSourceCode(@Nonnull Klass klass)
    {
        ImmutableList<Property> properties = klass
                .getProperties()
                .reject(Property::isPrivate);

        String dataFetchersSourceCode = properties
                .collectWith(this::getDataFetcherSourceCode, klass)
                .makeString("");

        ImmutableList<Classifier> associatedTypes = properties
                .selectInstancesOf(ReferenceProperty.class)
                .collect(ReferenceProperty::getType);

        ImmutableList<Classifier> importTypes = Lists.immutable.<Classifier>with(klass).newWithAll(associatedTypes);
        ImmutableList<String> imports = importTypes
                .collect(PackageableElement::getPackageName)
                .toSortedSet()
                .toImmutable()
                .collect(this::getImport);

        // @formatter:off
        //language=JAVA
        String sourceCode = "package " + klass.getPackageName() + ".graphql.type.runtime.wiring;\n"
                + '\n'
                + imports.makeString("")
                + "import cool.klass.graphql.type.runtime.wiring.provider.GraphQLTypeRuntimeWiringProvider;\n"
                + "import io.liftwizard.reladomo.graphql.data.fetcher.*;\n"
                + "import graphql.schema.PropertyDataFetcher;\n"
                + "import graphql.schema.idl.TypeRuntimeWiring.Builder;\n"
                + '\n'
                + "/**\n"
                + " * Auto-generated by {@link " + this.getClass().getCanonicalName() + "}\n"
                + " */\n"
                + "public class " + klass.getName() + "TypeRuntimeWiringProvider\n"
                + "        implements GraphQLTypeRuntimeWiringProvider\n"
                + "{\n"
                + "    @Override\n"
                + "    public Builder get()\n"
                + "    {\n"
                + "        Builder builder = new Builder();\n"
                + "        builder.typeName(\"" + klass.getName() + "\");\n"
                + dataFetchersSourceCode
                + "        return builder;\n"
                + "    }\n"
                + "}\n";
        // @formatter:on

        return sourceCode;
    }

    private String getImport(String packageName)
    {
        return "import " + packageName + ".*;\n";
    }

    private String getDataFetcherSourceCode(@Nonnull Property property, Klass owningClass)
    {
        DataFetcherSourceCodePropertyVisitor visitor = new DataFetcherSourceCodePropertyVisitor(owningClass, property);
        property.visit(visitor);

        return String.format(
                """
                                builder.dataFetcher(
                                        "%s",
                                        %s);
                        """,
                property.getName(),
                visitor.getSourceCode());
    }
}
