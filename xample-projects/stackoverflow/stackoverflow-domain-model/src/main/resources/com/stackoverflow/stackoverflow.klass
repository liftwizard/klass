/*
 * Simplified StackOverflow domain model. One question has many answers.
 */
package com.stackoverflow

// 'user' is just a special class that represents logged in users
// There must only be a single user class in the model, it must have a single key, and the key must be of type String. Other properties must be nullable
user User
    read
    systemTemporal
{
    // `read` keyword with no projection means create read services with the default read projection
    // The default read projection includes just this class and all its properties
    key userId        : String

    // TODO: String max lengths
    firstName         : String?
    lastName          : String?
    // TODO: Consider adding primitive types like email address and url
    email             : String?

    // TODO: Unique property sets
}

enumeration Status
{
    OPEN("Open"),
    ON_HOLD("On hold"),
    CLOSED("Closed"),
}

// TODO: Sets of unique properties other than keys
// TODO: Try to infer whether a query is for a unique item and assert multiplicity one
// TODO: Check for ownership cycles and give a good error message
// TODO: Errors for using reserved names like system, systemFrom, systemTo, etc.
// TODO: Errors for using versioned when not systemTemporal, audited when not systemTemporal, optimisticallyLocked when not versioned
class Question
    read(QuestionReadProjection)
    create(QuestionWriteProjection)
    update(QuestionWriteProjection)
    systemTemporal
    versioned
    audited
    optimisticallyLocked
{
    key id            : ID
    title             : String
    body              : String

    // TODO: Statemachine
    status            : Status
    deleted           : Boolean

    // TODO: Consider type inference on paramterized property parameters based on usage in relationship
    // orderBy natural key ascending is the default
    answersWithSubstring(substring: String[1..1]): Answer[0..*]
        orderBy: this.id ascending
    {
        this.id == Answer.questionId
            && Answer.body contains substring
    }

    activeAnswers(): Answer[0..*]
    {
        this.id == Answer.questionId
            && Answer.deleted == false
    }

    // TODO: Add keywords for declaring special properties. It may look redundant like:
    // TODO: system system: TemporalRange, but would allow renames like:
    // TODO: system known: TemporalRange

    // This isn't even a real property. It's referenced in criteria as a shorthand. For example Question.system == {time} is shorthand for Question.systemFrom <= {time} && Question.systemTo > {time}
    system            : TemporalRange

    // These two properties are implied by systemTemporal, and are not supposed to actually be declared
    systemFrom        : TemporalInstant
    systemTo          : TemporalInstant

    // TODO: private properties must not be used in projections

    // These three properties and two parameterized properties are implied by audited, and are not supposed to actually be declared
    // They could automatically be part of read projections and not write projections
    private createdById       : String

    // createdOn, or createdDate?
    createdOn         : Instant
    private lastUpdatedById   : String

    createdBy(): User[1..1]
    {
        this.createdById == User.userId
    }

    lastUpdatedBy(): User[1..1]
    {
        this.lastUpdatedById == User.userId
    }
}

// The _Version class is implied by the versioned annotation, and not supposed to actually be declared
// TODO: If you do declare one, we'd need a special keyword version instead of class
// TODO: Needs a syntax like versions(Question)
// TODO: Error message if versions does point to a version, if the versioned type isn't systemTemporal, maybe also if the versioned type isn't systemTemporal/versioned
/*
class QuestionVersion
    systemTemporal
    versions(Question)
{
    // Key properties copied from Question
    key id            : ID

    // The version number
    // It gets incremented automatically when anything in the version project (QuestionWriteProjection) gets edited
    // TODO: Consider changing the primitive names to int32, int64, float32, float64, id32, id64
    // TODO: Consider a primitive property type VersionNumber
    number            : Integer
}
*/

// TODO: Error message if versions doesn't point to a version class
association QuestionHasAnswer
{
    // TODO: *final* question: Question[1..1]
    question: Question[1..1]
    answers: Answer[0..*]
        orderBy: this.id ascending

    // TODO: check that the foreign key (questionId) is required since the to-one relationship end is also required (question: Question[1..1])
    // ordering by primary key ascending is the default
    relationship this.id == Answer.questionId
}

// The _HasVersion association is implied by the versioned annotation, and not supposed to actually be declared
// It could automatically be part of read projections and not write projections
/*
association QuestionHasVersion
{
    question: Question[1..1]
    version: QuestionVersion[1..1]

    // implied
    relationship this.id == QuestionVersion.id
            && this.system == QuestionVersion.system
}
*/

class Answer
    systemTemporal
    versioned
    audited
    optimisticallyLocked
{
    key id            : ID
    body              : String
    deleted           : Boolean
    // TODO: private *final* questionId: Long
    private questionId: Long
}

// TODO Model AnswerVote
// TODO Interface Vote
// TODO superclass AbstractVote
// TODO Aggregation for number of upvotes and downvotes
class QuestionVote
    systemTemporal
    audited
{
    key questionId    : Long
    key createdById   : String
    direction         : VoteDirection
}

enumeration VoteDirection
{
    UP("up"),
    DOWN("down"),
}

// TODO: Projection inheritance? QuestionReadProjection extends QuestionWriteProjection
projection QuestionReadProjection on Question
{
    // field names are "includes", field values are column headers when serializing to a tabular format
    id             : "Question id",
    title          : "Question title",
    body           : "Question body",
    status         : "Question status",
    deleted        : "Question is deleted",
    systemFrom     : "Question system From",
    systemTo       : "Question system To",
    createdById    : "Question created by ID",
    createdOn      : "Question created on",
    lastUpdatedById: "Question last updated by ID",

    answers        :
    {
        id  : "Answer id",
        body: "Answer body",
    },

    version        :
    {
        number: "Question version number",
    },
}

projection QuestionWriteProjection on Question
{
    title: "Question title",
    body : "Question body",
}

// TODO: Type inference on projection paramters
/*
projection FilteredAnswersProjection(substring: String[1..1]) on Question
{
    title                          : "Question title",
    body                           : "Question body",
    answersWithSubstring(substring):
    {
        body: "Answer body",
    },
}
*/

// Just embed inside the Question class?
service Question
{
    // TODO: matrix url params
    /*
        /api/question/{id: Long[1..1]}/{substring: String[1..1]}
            GET
            {
                multiplicity: many
                criteria    : this.id == id
                projection  : FilteredAnswersProjection(substring)
            }
        /api/question/{titleSubstring: String[1..1]}
            GET
            {
                multiplicity: many
                criteria    : this.title startsWith titleSubstring
                projection  : QuestionReadProjection
            }
    */
    // TODO: Consider forcing exact type matches. Meaning id's type here would be ID, not Long.
    /api/question/{id: Long[1..1]}
        GET
        {
            multiplicity: one
            criteria    : this.id == id
            projection  : QuestionReadProjection

            // TODO: format: json
        }
        PUT
        {
            // PUT, PATCH, and DELETE should implicitly get ?{version: Integer[1..1]} due to optimistic locking
            // TODO Version should be a primitive type, as in {version: Version[1..1]}
            multiplicity: one
            criteria    : this.id == id

            // TODO: Should differentiate between 'validate' 400 error and something like 'conflict' 409
            // Consider 412 Precondition Failed or 417 Expectation Failed instead of 400, and leave bad request for problems like invalid json, or mismatches with the meta model
            conflict    : this.id == QuestionVersion.id
                    && QuestionVersion.number == version
            // TODO: Allow anonymous/undeclared projections created from all owned association ends
            projection  : QuestionWriteProjection
        }
        DELETE
        {
            // TODO
            // PUT, PATCH, and DELETE should implicitly get ?version={version} due to optimistic locking
            multiplicity: one
            criteria    : this.id == id

            // 'authorize' is like 'validate' but should give 401 Unauthorized or 403 forbidden instead of 400
            // TODO: conditions implemented in code, like `|| native(UserIsModeratorClass)`
            authorize   : this.createdById == user

            // TODO: Should differentiate between 'validate' 400 error and something like 'conflict' 409
            conflict    : this.id == QuestionVersion.id
                    && QuestionVersion.number == version
            projection  : QuestionWriteProjection
        }
    /api/question/in?{ids: Long[0..*]}
        GET
        {
            multiplicity: many
            criteria    : this.id in ids
            projection  : QuestionReadProjection
        }
    /api/question/firstTwo
        GET
        {
            // TODO: Warn if multiplicity is one and criteria uses in clause, or anything other than equality on a unique property
            multiplicity: many
            criteria    : this.id in (1, 2)
            projection  : QuestionReadProjection
        }
    /api/question
        POST
        {
            multiplicity: one
            projection  : QuestionWriteProjection
        }
        GET
        {
            multiplicity: many
            criteria    : this.title startsWith "Why do"
            projection  : QuestionReadProjection
        }

    // TODO: Type inference on url parameters
    // TODO: Consider adding a primitive type UserId
    /api/user/{userId: String[1..1]}/questions
        GET
        {
            //?page=1&pageSize=25
            multiplicity: many
            criteria    : this.createdById == userId
            projection  : QuestionWriteProjection

            // Deliberately shallow
            orderBy     : this.createdOn

            // pageSize: ???
            // page: ???
        }
}
