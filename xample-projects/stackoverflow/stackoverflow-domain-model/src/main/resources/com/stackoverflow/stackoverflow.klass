/*
 * Simplified StackOverflow domain model. One question has many answers.
 */
// TODO: There should be a maven plugin that compiles the klass files and does nothing else, just to fail the build at the right module
package com.stackoverflow

// 'user' is just a special class that represents logged in users
// There must only be a single user class in the model, it must have a single key, and the key must be of type String. Other properties must be nullable
user User
    read
    systemTemporal
{
    // `read` keyword with no projection means create read services with the default read projection
    // The default read projection includes just this class and all its properties
    userId        : String key userId;

    // TODO: String max lengths
    firstName         : String?;
    lastName          : String?;
    // TODO: Consider adding primitive types like email address and url
    email             : String?;

    // TODO: Unique property sets
}

enumeration Status
{
    OPEN("Open"),
    ON_HOLD("On hold"),
    CLOSED("Closed"),
}

// TODO: Sets of unique properties other than keys
// TODO: Try to infer whether a query is for a unique item and assert multiplicity one
// TODO: Check for ownership cycles and give a good error message
// TODO: Errors for using reserved names like system, systemFrom, systemTo, etc.
// TODO: Errors for using versioned when not systemTemporal, audited when not systemTemporal, optimisticallyLocked when not versioned
class Question
    read(QuestionReadProjection)
    create(QuestionWriteProjection)
    update(QuestionWriteProjection)
    systemTemporal
    versioned
    audited
    optimisticallyLocked
{
    // TODO: When copying id to QuestionVersion, id should be Long key but not id.
    id                : Long key id;
    title             : String;
    body              : String;

    // TODO: Statemachine
    status            : Status;
    deleted           : Boolean;

    // TODO: Consider type inference on paramterized property parameters based on usage in relationship
    // orderBy natural key ascending is the default
    answersWithSubstring(substring: String[1..1]): Answer[0..*]
        orderBy: this.id ascending
    {
        this.id == Answer.questionId
            && Answer.body contains substring
    }

    activeAnswers(): Answer[0..*]
    {
        this.id == Answer.questionId
            && Answer.deleted == false
    }

    // TODO: Add keywords for declaring special properties. It may look redundant like:
    // TODO: system system: TemporalRange, but would allow renames like:
    // TODO: system known: TemporalRange

    // This isn't even a real property. It's referenced in criteria as a shorthand. For example Question.system == {time} is shorthand for Question.systemFrom <= {time} && Question.systemTo > {time}
    system            : TemporalRange system;

    // These two properties are implied by systemTemporal, and are not supposed to actually be declared
    systemFrom        : TemporalInstant system from;
    systemTo          : TemporalInstant system to;

    // TODO: private properties must not be used in projections

    // These three properties and two parameterized properties are implied by audited, and are not supposed to actually be declared
    // They could automatically be part of read projections and not write projections
    createdById       : String private createdBy;

    // createdOn, or createdDate?
    createdOn         : Instant createdOn;
    lastUpdatedById   : String private lastUpdatedBy;

    createdBy(): User[1..1] createdBy
    {
        this.createdById == User.userId
    }

    lastUpdatedBy(): User[1..1] lastUpdatedBy
    {
        this.lastUpdatedById == User.userId
    }
}

// The _Version class is implied by the versioned annotation, and not supposed to actually be declared
// TODO: If you do declare one, we'd need a special keyword version instead of class
// TODO: Needs a syntax like versions(Question)
// TODO: Error message if versions does point to a version, if the versioned type isn't systemTemporal, maybe also if the versioned type isn't systemTemporal/versioned
/*
class QuestionVersion
    systemTemporal
    versions(Question)
{
    // Key properties copied from Question
    key id            : ID

    // The version number
    // It gets incremented automatically when anything in the version project (QuestionWriteProjection) gets edited
    // TODO: Consider changing the primitive names to int32, int64, float32, float64, id32, id64
    // TODO: Consider a primitive property type VersionNumber
    number            : Integer
}
*/

// TODO: Error message if versions doesn't point to a version class
association QuestionHasAnswer
{
    // TODO: *final* question: Question[1..1]
    question: Question[1..1] final;
    answers: Answer[0..*]
        orderBy: this.id ascending;

    // TODO: check that the foreign key (questionId) is required since the to-one relationship end is also required (question: Question[1..1])
    // ordering by primary key ascending is the default
    relationship this.id == Answer.questionId
}

// The _HasVersion association is implied by the versioned annotation, and not supposed to actually be declared
// It could automatically be part of read projections and not write projections
/*
association QuestionHasVersion
{
    question: Question[1..1];
    version: QuestionVersion[1..1];

    // implied
    relationship this.id == QuestionVersion.id
            && this.system == QuestionVersion.system
}
*/

class Answer
    systemTemporal
    versioned
    audited
    optimisticallyLocked
{
    id                            : Long key id;
    body                          : String;
    deleted                       : Boolean;

    // TODO: questionId: Long private *final*
    questionId                    : Long private;
}

// TODO Model AnswerVote
// TODO Interface Vote
// TODO superclass AbstractVote
// TODO Aggregation for number of upvotes and downvotes
class QuestionVote
    systemTemporal
    audited
{
    questionId                    : Long key;
    createdById                   : String key createdBy;
    direction                     : VoteDirection;
}

enumeration VoteDirection
{
    UP("up"),
    DOWN("down"),
}

class Tag
    systemTemporal
    versioned
    audited
    optimisticallyLocked
{
    name                  : String key;
    description           : String;
}

class QuestionTagMapping
    systemTemporal
{
    questionId: Long key private;
    tagName: String key private;
}

association QuestionHasTagMappings
{
    question: Question[1..1] final;
    tags: QuestionTagMapping[0..*] owned
        orderBy: this.tagName;

    relationship this.id == QuestionTagMapping.questionId
}

association TagHasQuestionMappings
{
    tag: Tag[1..1] final;
    questions: QuestionTagMapping[0..*]
        orderBy: this.questionId;

    relationship this.name == QuestionTagMapping.tagName
}

// TODO: Projection inheritance? QuestionReadProjection extends QuestionWriteProjection
projection QuestionReadProjection on Question
{
    // field names are "includes", field values are column headers when serializing to a tabular format
    id             : "Question id",
    title          : "Question title",
    body           : "Question body",
    status         : "Question status",
    deleted        : "Question is deleted",
    systemFrom     : "Question system From",
    systemTo       : "Question system To",
    createdById    : "Question created by ID",
    createdOn      : "Question created on",
    lastUpdatedById: "Question last updated by ID",

    answers        :
    {
        id  : "Answer id",
        body: "Answer body",
    },

    tags           :
    {
        tag:
        {
            name: "Question tag name",
        },
    },

    version        :
    {
        number: "Question version number",
    },
}

// TODO: Totally redo write projections. It doesn't make sense for them to contain dataTypeProperties
projection QuestionWriteProjection on Question
{
    tags:
    {
    },
}

// TODO: Type inference on projection paramters
/*
projection FilteredAnswersProjection(substring: String[1..1]) on Question
{
    title                          : "Question title",
    body                           : "Question body",
    answersWithSubstring(substring):
    {
        body: "Answer body",
    },
}
*/

// Just embed inside the Question class?
service Question
{
    // TODO: matrix url params
    /*
        /api/question/{id: Long[1..1]}/{substring: String[1..1]}
            GET
            {
                multiplicity: many
                criteria    : this.id == id
                projection  : FilteredAnswersProjection(substring)
            }
        /api/question/{titleSubstring: String[1..1]}
            GET
            {
                multiplicity: many
                criteria    : this.title startsWith titleSubstring
                projection  : QuestionReadProjection
            }
    */
    // TODO: Service syntax. Parameter must be a message type or projection type.
    /*
    service getById(id: Long[1..1]): QuestionReadProjection[1]
    {
        resource: QuestionResource
        verb    : GET
        url     : /api/question/{id: Long[1..1]}
        criteria: this.id == id
    }
    */

    // TODO: Consider forcing exact type matches. Meaning id's type here would be ID, not Long.
    /api/question/{id: Long[1..1]}
        GET
        {
            multiplicity: one;
            criteria    : this.id == id;
            projection  : QuestionReadProjection;
            // TODO: format: json
        }
        PUT
        {
            // PUT, PATCH, and DELETE should implicitly get ?{version: Integer[1..1]} due to optimistic locking
            // TODO Version should be a primitive type, as in {version: Version[1..1]}
            multiplicity: one;
            criteria    : this.id == id;
            // TODO: Consider 'conflict' 409, 412 Precondition Failed, or 417 Expectation Failed
            // TODO: Allow anonymous/undeclared projections created from all owned association ends
            projection  : QuestionWriteProjection;
        }
        DELETE
        {
            // TODO
            // PUT, PATCH, and DELETE should implicitly get ?version={version} due to optimistic locking
            multiplicity: one;
            criteria    : this.id == id;
            // 'authorize' is like 'validate' but should give 401 Unauthorized or 403 forbidden instead of 400
            // TODO: conditions implemented in code, like `|| native(UserIsModeratorClass)`
            authorize   : this.createdById == user;
            projection  : QuestionWriteProjection;
        }
    /api/question/in?{ids: Long[0..*]}
        GET
        {
            multiplicity: many;
            criteria    : this.id in ids;
            projection  : QuestionReadProjection;
        }
    // TODO: Test urls containing unusual characters like emoji, and %20
    /api/question/firstTwo
        GET
        {
            // TODO: Warn if multiplicity is one and criteria uses in clause, or anything other than equality on a unique property
            multiplicity: many;
            criteria    : this.id in (1, 2);
            projection  : QuestionReadProjection;
        }
    /api/question
        POST
        {
            multiplicity: one;
            projection  : QuestionWriteProjection;
        }
        GET
        {
            multiplicity: many;
            criteria    : this.title startsWith "Why do";
            projection  : QuestionReadProjection;
        }

    // TODO: Type inference on url parameters
    // TODO: Consider adding a primitive type UserId
    /api/user/{userId: String[1..1]}/questions
        GET
        {
            //?page=1&pageSize=25
            multiplicity: many;
            criteria    : this.createdById == userId;
            projection  : QuestionWriteProjection;

            // Deliberately shallow
            orderBy     : this.createdOn;

            // pageSize: ???
            // page: ???
        }
}
