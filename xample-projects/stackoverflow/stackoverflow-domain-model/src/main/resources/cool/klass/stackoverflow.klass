/*
 * Simplified StackOverflow domain model. One question has many answers.
 */
package com.stackoverflow

// 'user' is just a special class that represents logged in users
// There must only be a single user class in the model, it must have a single key, and the key must be of type String. Other properties must be nullable
user User
    read
    systemTemporal
{
    // `read` keyword with no projection means create read services with the default read projection
    // The default read projection includes just this class and all its properties
    key userId        : String

    // TODO: String max lengths
    firstName         : String?
    lastName          : String?
    email             : String?
}

enumeration Status
{
    OPEN("Open"),
    ON_HOLD("On hold"),
    CLOSED("Closed"),
}

class Question
    read(QuestionReadProjection)
    create(QuestionWriteProjection)
    update(QuestionWriteProjection)
    systemTemporal
    versioned
    audited
    optimisticallyLocked
{
    key id            : ID
    title             : String
    body              : String

    // TODO: Statemachine
    status            : Status
    deleted           : Boolean

    // TODO: Consider type inference on paramterized property parameters based on usage in relationship
    // orderBy natural key ascending is the default
    answersWithSubstring(substring: String[1..1]): Answer[0..*]
        orderBy: this.id ascending
    {
        this.id == Answer.questionId
            && Answer.body contains substring
    }

    activeAnswers(): Answer[0..*]
    {
        this.id == Answer.questionId
            && Answer.deleted == false
    }

    // This isn't even a real property. It's referenced in criteria as a shorthand. For example Question.system == {time} is shorthand for Question.systemFrom <= {time} && Question.systemTo > {time}
    system            : TemporalRange

    // These two properties are implied by systemTemporal, and are not supposed to actually be declared
    systemFrom        : TemporalInstant
    systemTo          : TemporalInstant

    // These three properties and two parameterized properties are implied by audited, and are not supposed to actually be declared
    // They could automatically be part of read projections and not write projections
    createdById       : String

    // createdOn, or createdDate?
    createdOn         : Instant
    lastUpdatedById   : String

    createdBy(): User[1..1]
    {
        this.createdById == User.userId
    }

    lastUpdatedBy(): User[1..1]
    {
        this.lastUpdatedById == User.userId
    }
}

// The _Version class is implied by the versioned annotation, and not supposed to actually be declared
class QuestionVersion
    systemTemporal
{
    // Key properties copied from Question
    key id            : ID

    // The version number
    // It gets incremented automatically when anything in the version project (QuestionWriteProjection) gets edited
    // TODO: Consider changing the primitive names to int32, int64, float32, float64, id32, id64
    number            : Integer
}

association QuestionHasAnswer
{
    question: Question[1..1]
    answers: Answer[0..*]
        orderBy: this.id ascending

    // ordering by primary key ascending is the default
    relationship this.id == Answer.questionId
}

// The _HasVersion association is implied by the versioned annotation, and not supposed to actually be declared
// It could automatically be part of read projections and not write projections
association QuestionHasVersion
{
    question: Question[1..1]
    version: QuestionVersion[1..1]

    // implied
    relationship this.id == QuestionVersion.id
            && this.system == QuestionVersion.system
}

class Answer
    systemTemporal
    versioned
    audited
    optimisticallyLocked
{
    key id            : ID
    body              : String
    deleted           : Boolean
    private questionId: Long
}

// TODO Model AnswerVote
// TODO Interface Vote
// TODO superclass AbstractVote
// TODO Aggregation for number of upvotes and downvotes
class QuestionVote
    systemTemporal
    audited
{
    key questionId    : Long
    key createdById   : String
    direction         : VoteDirection
}

enumeration VoteDirection
{
    UP("up"),
    DOWN("down"),
}

// TODO: Projection inheritance? QuestionReadProjection extends QuestionWriteProjection
projection QuestionReadProjection on Question
{
    // field names are "includes", field values are column headers when serializing to a tabular format
    title  : "Question title",
    body   : "Question body",
    answers:
    {
        body: "Answer body",
    },
}

projection QuestionWriteProjection on Question
{
    title: "Question title",
    body : "Question body",
}

// TODO: Type inference on projection paramters
projection FilteredAnswersProjection(substring: String[1..1]) on Question
{
    title                          : "Question title",
    body                           : "Question body",
    answersWithSubstring(substring):
    {
        body: "Answer body",
    },
}

// Just embed inside the Question class?
service Question
{
    // TODO: matrix url params
    /api/question/{id: Long[1..1]}/{substring: String[1..1]}
        GET
        {
            multiplicity: many
            criteria    : this.id == id
            projection  : FilteredAnswersProjection(substring)
        }
    /api/question/{titleSubstring: String[1..1]}
        GET
        {
            multiplicity: many
            criteria    : this.title startsWith titleSubstring
            projection  : QuestionReadProjection
        }
    /api/question/{id: Long[1..1]}
        GET
        {
            multiplicity: one
            criteria    : this.id == id
            projection  : QuestionReadProjection
        }
    /api/question/in/{id: Long[0..*]}
        GET
        {
            multiplicity: one
            criteria    : this.id in id
            projection  : QuestionReadProjection
        }
    /api/question/firstTwo
        GET
        {
            multiplicity: one
            criteria    : this.id in (1, 2)
            projection  : QuestionReadProjection
        }
    /api/question/{id: Long[1..1]}?{version: Integer[1..1]}
        PUT
        {
            // PUT, PATCH, and DELETE should implicitly get ?version={version} due to optimistic locking
            multiplicity: one
            criteria    : this.id == id

            // TODO: Should differentiate between 'validate' 400 error and something like 'conflict' 409
            // Consider 412 Precondition Failed or 417 Expectation Failed instead of 400, and leave bad request for problems like invalid json, or mismatches with the meta model
            conflict    : this.id == QuestionVersion.id
                && QuestionVersion.number == version
            projection  : QuestionWriteProjection
        }
        DELETE
        {
            // PUT, PATCH, and DELETE should implicitly get ?version={version} due to optimistic locking
            multiplicity: one
            criteria    : this.id == id

            // 'authorize' is like 'validate' but should give 401 Unauthorized or 403 forbidden instead of 400
            // TODO: conditions implemented in code, like `|| native(UserIsModeratorClass)`
            authorize   : this.createdById == user

            // TODO: Should differentiate between 'validate' 400 error and something like 'conflict' 409
            validate    : this.id == QuestionVersion.id
                    && QuestionVersion.number == version
            projection  : QuestionWriteProjection
        }
    /api/question
        POST
        {
            multiplicity: one
            projection  : QuestionWriteProjection
        }
        GET
        {
            multiplicity: many
            criteria    : this.title startsWith "Why do"
            projection  : QuestionReadProjection
        }

    // TODO: Type inference on url parameters
    /api/user/{userId: String[1..1]}/questions
        GET
        {
            //?page=1&pageSize=25
            multiplicity: many
            criteria    : this.createdById == userId
            projection  : QuestionWriteProjection

            // Deliberately shallow
            orderBy     : this.createdOn

            // pageSize: ???
            // page: ???
        }
}
