package klass.model.meta.domain

class Class
    transient
{
    name                          : String key;
    packageName                   : String private;
    // TODO: Ordinals should have a syntax and be inferred using macros
    ordinal                       : Integer;
}

enumeration PrimitiveType
{
    INTEGER("Integer"),
    LONG("Long"),
    DOUBLE("Double"),
    FLOAT("Float"),
    BOOLEAN("Boolean"),
    STRING("String"),
    INSTANT("Instant"),
    LOCAL_DATE("LocalDate"),
    TEMPORAL_INSTANT("TemporalInstant"),
    TEMPORAL_RANGE("TemporalRange"),
}

enumeration Multiplicity
{
    ZERO_TO_ONE("0..1"),
    ONE_TO_ONE("1..1"),
    ZERO_TO_MANY("0..*"),
    ONE_TO_MANY("1..*"),
}

class PrimitiveProperty
    transient
{
    className                     : String key;
    name                          : String key;
    primitiveType                 : PrimitiveType;
    optional                      : Boolean;
    key                           : Boolean;
    id                            : Boolean;
    ordinal                       : Integer;
}

association ClassHasPrimitiveTypeProperties
{
    owningClass: Class[1..1];
    primitiveProperties: PrimitiveProperty[0..*] owned
    // TODO: Change the orderBy syntax to orderBy(this.ordinal)
        orderBy: this.ordinal;

    relationship this.name == PrimitiveProperty.className
}

class Enumeration
    transient
{
    name: String key;
    packageName: String private;
}

class EnumerationLiteral
    transient
{
    enumerationName               : String key;
    prettyName                    : String;
    name: String key;
}

association EnumerationHasLiterals
{
    enumeration: Enumeration[1..1];
    enumerationLiterals: EnumerationLiteral[1..*];

    relationship this.name == EnumerationLiteral.enumerationName
}

class EnumerationProperty
    transient
{
    className                     : String key;
    name                          : String key;
    enumerationName               : String private;
    optional                      : Boolean;
    key                           : Boolean;
    ordinal                       : Integer;
}

association EnumerationPropertyHasEnumeration
{
    enumerationProperty: EnumerationProperty[0..*];
    enumeration: Enumeration[1..1];

    relationship this.enumerationName == Enumeration.name
}

association ClassHasEnumerationProperties
{
    owningClass: Class[1..1];
    enumerationProperties: EnumerationProperty[0..*];

    relationship this.name == EnumerationProperty.className
}

enumeration AssociationEndDirection
{
    SOURCE("source"),
    TARGET("target"),
}

class Association
    transient
{
    name                          : String key;
    packageName: String private;

    source(): AssociationEnd[1..1]
    {
        this.name == AssociationEnd.associationName
            && AssociationEnd.direction == AssociationEndDirection.SOURCE
    }

    target(): AssociationEnd[1..1]
    {
        this.name == AssociationEnd.associationName
            && AssociationEnd.direction == AssociationEndDirection.TARGET
    }
}

class AssociationEnd
    transient
{
    owningClassName               : String key private;
    name: String key;
    associationName: String;
    direction: AssociationEndDirection;
    multiplicity                  : Multiplicity;
    resultTypeName                : String private;
    ordinal                       : Integer;
}

// simplification, ideally we'd model an association as having exactly two ends
association AssociationHasEnds
{
    owningAssociation: Association[1..1];
    associationEnds: AssociationEnd[0..*];

    relationship this.name == AssociationEnd.associationName
}

association ClassHasAssociationEnds
{
    owningClass: Class[1..1];
    associationEnds: AssociationEnd[0..*];

    relationship this.name == AssociationEnd.owningClassName
}

association AssociationEndHasResultType
{
    associationEndsResultTypeOf: AssociationEnd[0..*];
    resultType: Class[1..1];

    relationship this.resultTypeName == Class.name
}

class ParameterizedProperty
    transient
{
    owningClassName               : String key private;
    name                          : String key;
    multiplicity: Multiplicity;
    resultTypeName: String private;
}

association ClassHasParameterizedProperties
{
    owningClass: Class[1..1];
    parameterizedProperties: ParameterizedProperty[0..*] owned;

    relationship this.name == ParameterizedProperty.owningClassName
}

association ParameterizedPropertyHasResultType
{
    parameterizedPropertiesResultTypeOf: ParameterizedProperty[0..*];
    resultType: Class[1..1];

    relationship this.resultTypeName == Class.name
}

class AssociationEndOrdering
    transient
{
    associationName               : String key private;
    name                          : String;
    multiplicity: Multiplicity;
    direction                     : AssociationEndDirection key;
    orderingId                    : Long private;
}

class ParameterizedPropertyOrdering
    transient
{
    owningClassName               : String private key;
    name                          : String key;
    orderingId: Long private;
}

association AssociationEndHasOrdering
{
    associationEnd: AssociationEnd[1..1];
    associationEndOrdering: AssociationEndOrdering[0..1];

    relationship this.associationName == AssociationEndOrdering.associationName
            && this.direction == AssociationEndOrdering.direction
}

association ParameterizedPropertyHasOrdering
{
    parameterizedProperty: ParameterizedProperty[1..1];
    parameterizedPropertyOrdering: ParameterizedPropertyOrdering[0..*];

    relationship this.owningClassName == ParameterizedPropertyOrdering.owningClassName
            && this.name == ParameterizedPropertyOrdering.name
}

association AssociationEndOrderingHasParts
{
    associationEndOrdering: AssociationEndOrdering[1..1];
    ordering: Ordering[1..*];

    relationship this.orderingId == Ordering.id
}

association ParameterizedPropertyOrderingHasParts
{
    parameterizedPropertyOrdering: ParameterizedPropertyOrdering[1..1];
    ordering: Ordering[1..1];

    // TODO: error when there's no "this"
    // relationship ParameterizedPropertyOrdering.orderingId == Ordering.id
    // TODO: error when the foreign key for a to-many is its entire primary key
    // relationship ParameterizedPropertyOrdering.orderingId == Ordering.id
    relationship this.orderingId == Ordering.id
}

class Ordering
    transient
{
    id                            : Long id key;
}

// Split into data type / enum type order bys?
class OrderingPart
    transient
{
    orderingId                    : Long key;

    // TODO: order keyword for properties meant for sorting?
    ordinal                       : Integer key;
    className: String private;
    propertyName                  : String private;
    direction                     : OrderingDirection;
}

association OrderingHasParts
{
    ordering: Ordering[1..1];
    orderingParts: OrderingPart[1..*]
        orderBy: this.ordinal;

    relationship this.id == OrderingPart.orderingId
}

enumeration OrderingDirection
{
    ASCENDING("ascending"),
    DESCENDING("descending"),
}

association OrderingPartHasDataTypeProperty
{
    orderingParts: OrderingPart[0..*];
    dataTypeProperty: PrimitiveProperty[1..1];

    relationship this.className == PrimitiveProperty.className
            && this.propertyName == PrimitiveProperty.name
}

association OrderingPartHasEnumerationProperty
{
    orderingParts: OrderingPart[0..*];
    enumerationProperty: EnumerationProperty[1..1];

    relationship this.className == EnumerationProperty.className
            && this.propertyName == EnumerationProperty.name
}

association ParameterizedPropertyHasParameters
{
    parameterizedProperty: ParameterizedProperty[1..1];
    parameters: ParameterizedPropertyParameter[0..*];

    relationship this.owningClassName == ParameterizedPropertyParameter.parameterizedPropertyClassName
            && this.name == ParameterizedPropertyParameter.parameterizedPropertyName
}

class ParameterizedPropertyParameter
    transient
{
    parameterizedPropertyClassName: String key private;
    parameterizedPropertyName: String key;
    name: String;
}

/*
association ParameterizedPropertyHasCriteria
{

}
*/

class Package
    transient
{
    fullyQualifiedName            : String key;
}

association PackageHasClasses
{
    owningPackage: Package[1..1];
    classes: Class[0..*];

    relationship this.fullyQualifiedName == Class.packageName
}

association PackageHasEnumerations
{
    owningPackage: Package[1..1];
    enumerations: Enumeration[0..*];

    relationship this.fullyQualifiedName == Enumeration.packageName
}

association PackageHasAssociations
{
    owningPackage: Package[1..1];
    associations: Association[0..*];

    relationship this.fullyQualifiedName == Association.packageName
}

projection ClassReadProjection on Class
{
    name                 : "Class name",
    packageName          : "Class package name",
    primitiveProperties  :
    {
        name         : "Primitive property name",
        primitiveType: "Primitive property type",
        optional     : "Primitive property is optional",
        key          : "Primitive property is key",
        id           : "Primitive property is id",
        ordinal      : "Primitive property ordinal",
    },
    enumerationProperties:
    {
        name       : "Enumeration property name",
        optional   : "Enumeration property is optional",
        key        : "Enumeration property is key",
        enumeration:
        {
            name: "Enumeration name",
        },
    },
    associationEnds      :
    {
        name             : "Association end name",
        direction        : "Association end direction",
        multiplicity     : "Association end multiplicity",
        resultType       :
        {
            name: "Association end result type name",
        },
        owningAssociation:
        {
            name: "Association end owning association name",
        },
    },
}

service Class
{
    /api/meta/class/{className: String[1..1]}
        GET
        {
            multiplicity: one;
            criteria    : this.name == className;
            projection  : ClassReadProjection;
        }
    /api/meta/class
        GET
        {
            multiplicity: many;
            criteria    : all;
            projection  : ClassReadProjection;
        }
}
