package klass.model.meta.domain

class Class
    transient
{
    name                          : String key;
    inferred                      : Boolean;
    packageName                   : String private;
    // TODO: Ordinals should have a syntax and be inferred using macros
    ordinal                       : Integer;
}

enumeration PrimitiveType
{
    INTEGER("Integer"),
    LONG("Long"),
    DOUBLE("Double"),
    FLOAT("Float"),
    BOOLEAN("Boolean"),
    STRING("String"),
    INSTANT("Instant"),
    LOCAL_DATE("LocalDate"),
    TEMPORAL_INSTANT("TemporalInstant"),
    TEMPORAL_RANGE("TemporalRange"),
}

enumeration Multiplicity
{
    ZERO_TO_ONE("0..1"),
    ONE_TO_ONE("1..1"),
    ZERO_TO_MANY("0..*"),
    ONE_TO_MANY("1..*"),
}

class PrimitiveProperty
    transient
{
    className                     : String key;
    name                          : String key;
    inferred                      : Boolean;
    primitiveType                 : PrimitiveType;
    optional                      : Boolean;
    key                           : Boolean;
    id                            : Boolean;
    ordinal                       : Integer;
}

association ClassHasPrimitiveTypeProperties
{
    owningClass: Class[1..1];
    primitiveProperties: PrimitiveProperty[0..*] owned
    // TODO: Change the orderBy syntax to orderBy(this.ordinal)
        orderBy: this.ordinal;

    relationship this.name == PrimitiveProperty.className
}

class Enumeration
    transient
{
    name                          : String key;
    inferred                      : Boolean;
    packageName                   : String private;
    ordinal                       : Integer;
}

class EnumerationLiteral
    transient
{
    enumerationName               : String key;
    name                          : String key;
    inferred                      : Boolean;
    prettyName                    : String;
    ordinal                       : Integer;
}

association EnumerationHasLiterals
{
    enumeration: Enumeration[1..1];
    enumerationLiterals: EnumerationLiteral[1..*]
        orderBy: this.ordinal;

    relationship this.name == EnumerationLiteral.enumerationName
}

class EnumerationProperty
    transient
{
    className                     : String key;
    name                          : String key;
    inferred                      : Boolean;
    enumerationName               : String private;
    optional                      : Boolean;
    key                           : Boolean;
    ordinal                       : Integer;
}

association EnumerationPropertyHasEnumeration
{
    enumerationProperty: EnumerationProperty[0..*];
    enumeration: Enumeration[1..1];

    relationship this.enumerationName == Enumeration.name
}

association ClassHasEnumerationProperties
{
    owningClass: Class[1..1];
    enumerationProperties: EnumerationProperty[0..*]
        orderBy: this.ordinal;

    relationship this.name == EnumerationProperty.className
}

class PrimitivePropertyModifier
    transient
{
    className                     : String key;
    propertyName                  : String key;
    name                          : String key;
    inferred                      : Boolean;
    ordinal                       : Integer;
}

class EnumerationPropertyModifier
    transient
{
    className                     : String key;
    propertyName                  : String key;
    name                          : String key;
    inferred                      : Boolean;
    ordinal                       : Integer;
}

association PrimitivePropertyHasModifiers
{
    primitiveProperty: PrimitiveProperty[1..1];
    primitivePropertyModifiers: PrimitivePropertyModifier[0..*]
        orderBy: this.ordinal;

    relationship this.className == PrimitivePropertyModifier.className
            && this.name == PrimitivePropertyModifier.propertyName
}

association EnumerationPropertyHasModifiers
{
    enumerationProperty: EnumerationProperty[1..1];
    enumerationPropertyModifiers: EnumerationPropertyModifier[0..*]
        orderBy: this.ordinal;

    relationship this.className == EnumerationPropertyModifier.className
            && this.name == EnumerationPropertyModifier.propertyName
}

class ClassModifier
    transient
{
    className                     : String key;
    name                          : String key;
    inferred                      : Boolean;
    ordinal                       : Integer;
}

association ClassHasModifiers
{
    owningClass: Class[1..1];
    classModifiers: ClassModifier[0..*]
        orderBy: this.ordinal;

    relationship this.name == ClassModifier.className
}

enumeration AssociationEndDirection
{
    SOURCE("source"),
    TARGET("target"),
}

class Association
    transient
{
    name                          : String key;
    inferred                      : Boolean;
    packageName                   : String private;
    ordinal                       : Integer;

    source(): AssociationEnd[1..1]
    {
        this.name == AssociationEnd.associationName
            && AssociationEnd.direction == AssociationEndDirection.SOURCE
    }

    target(): AssociationEnd[1..1]
    {
        this.name == AssociationEnd.associationName
            && AssociationEnd.direction == AssociationEndDirection.TARGET
    }
}

class AssociationEnd
    transient
{
    owningClassName               : String key private;
    name                          : String key;
    inferred                      : Boolean;
    associationName               : String;
    direction                     : AssociationEndDirection;
    multiplicity                  : Multiplicity;
    resultTypeName                : String private;
    ordinal                       : Integer;
}

// simplification, ideally we'd model an association as having exactly two ends
association AssociationHasEnds
{
    owningAssociation: Association[1..1];
    associationEnds: AssociationEnd[0..*]
        orderBy: this.direction;

    relationship this.name == AssociationEnd.associationName
}

association ClassHasAssociationEnds
{
    owningClass: Class[1..1];
    associationEnds: AssociationEnd[0..*];
    // TODO: Order by this.owningAssociation.ordinal

    relationship this.name == AssociationEnd.owningClassName
}

association AssociationEndHasResultType
{
    associationEndsResultTypeOf: AssociationEnd[0..*];
    resultType: Class[1..1];

    relationship this.resultTypeName == Class.name
}

class AssociationEndModifier
    transient
{
    owningClassName               : String key;
    associationEndName            : String key;
    name                          : String key;
    inferred                      : Boolean;
    ordinal                       : Integer;
}

association AssociationEndHasModifiers
{
    associationEnd: AssociationEnd[1..1];
    associationEndModifiers: AssociationEndModifier[0..*]
        orderBy: this.ordinal;

    relationship this.owningClassName == AssociationEndModifier.owningClassName
            && this.name == AssociationEndModifier.associationEndName
}

class ParameterizedProperty
    transient
{
    owningClassName               : String key private;
    name                          : String key;
    inferred                      : Boolean;
    multiplicity                  : Multiplicity;
    resultTypeName                : String private;
    ordinal                       : Integer;
}

association ClassHasParameterizedProperties
{
    owningClass: Class[1..1];
    parameterizedProperties: ParameterizedProperty[0..*] owned
        orderBy: this.ordinal;

    relationship this.name == ParameterizedProperty.owningClassName
}

association ParameterizedPropertyHasResultType
{
    parameterizedPropertiesResultTypeOf: ParameterizedProperty[0..*];
    resultType: Class[1..1];

    relationship this.resultTypeName == Class.name
}

class AssociationEndOrdering
    transient
{
    associationName               : String key private;
    name                          : String;
    inferred                      : Boolean;
    multiplicity                  : Multiplicity;
    direction                     : AssociationEndDirection key;
    orderingId                    : Long private;
}

class ParameterizedPropertyOrdering
    transient
{
    owningClassName               : String private key;
    name                          : String key;
    inferred                      : Boolean;
    orderingId                    : Long private;
}

association AssociationEndHasOrdering
{
    associationEnd: AssociationEnd[1..1];
    associationEndOrdering: AssociationEndOrdering[0..1];

    relationship this.associationName == AssociationEndOrdering.associationName
            && this.direction == AssociationEndOrdering.direction
}

association ParameterizedPropertyHasOrdering
{
    parameterizedProperty: ParameterizedProperty[1..1];
    parameterizedPropertyOrdering: ParameterizedPropertyOrdering[0..*];

    relationship this.owningClassName == ParameterizedPropertyOrdering.owningClassName
            && this.name == ParameterizedPropertyOrdering.name
}

association AssociationEndOrderingHasParts
{
    associationEndOrdering: AssociationEndOrdering[1..1];
    ordering: Ordering[1..*];

    relationship this.orderingId == Ordering.id
}

association ParameterizedPropertyOrderingHasParts
{
    parameterizedPropertyOrdering: ParameterizedPropertyOrdering[1..1];
    ordering: Ordering[1..1];

    // TODO: error when there's no "this"
    // relationship ParameterizedPropertyOrdering.orderingId == Ordering.id
    // TODO: error when the foreign key for a to-many is its entire primary key
    // relationship ParameterizedPropertyOrdering.orderingId == Ordering.id
    relationship this.orderingId == Ordering.id
}

class Ordering
    transient
{
    id                            : Long id key;
    inferred                      : Boolean;
}

// Split into data type / enum type order bys?
class OrderingPart
    transient
{
    orderingId                    : Long key;
    inferred                      : Boolean;

    // TODO: order keyword for properties meant for sorting?
    ordinal                       : Integer key;
    className                     : String private;
    propertyName                  : String private;
    direction                     : OrderingDirection;
}

association OrderingHasParts
{
    ordering: Ordering[1..1];
    orderingParts: OrderingPart[1..*]
        orderBy: this.ordinal;

    relationship this.id == OrderingPart.orderingId
}

enumeration OrderingDirection
{
    ASCENDING("ascending"),
    DESCENDING("descending"),
}

association OrderingPartHasDataTypeProperty
{
    orderingParts: OrderingPart[0..*];
    dataTypeProperty: PrimitiveProperty[1..1];

    relationship this.className == PrimitiveProperty.className
            && this.propertyName == PrimitiveProperty.name
}

association OrderingPartHasEnumerationProperty
{
    orderingParts: OrderingPart[0..*];
    enumerationProperty: EnumerationProperty[1..1];

    relationship this.className == EnumerationProperty.className
            && this.propertyName == EnumerationProperty.name
}

association ParameterizedPropertyHasParameters
{
    parameterizedProperty: ParameterizedProperty[1..1];
    parameters: ParameterizedPropertyParameter[0..*];

    relationship this.owningClassName == ParameterizedPropertyParameter.parameterizedPropertyClassName
            && this.name == ParameterizedPropertyParameter.parameterizedPropertyName
}

class ParameterizedPropertyParameter
    transient
{
    parameterizedPropertyClassName: String key private;
    parameterizedPropertyName     : String key;
    name                          : String;
    inferred                      : Boolean;
}

/*
association ParameterizedPropertyHasCriteria
{

}
*/

class Package
    transient
{
    fullyQualifiedName            : String key;
}

association PackageHasClasses
{
    owningPackage: Package[1..1];
    classes: Class[0..*]
        orderBy: this.ordinal;

    relationship this.fullyQualifiedName == Class.packageName
}

association PackageHasEnumerations
{
    owningPackage: Package[1..1];
    enumerations: Enumeration[0..*]
        orderBy: this.ordinal;

    relationship this.fullyQualifiedName == Enumeration.packageName
}

association PackageHasAssociations
{
    owningPackage: Package[1..1];
    associations: Association[0..*]
        orderBy: this.ordinal;

    relationship this.fullyQualifiedName == Association.packageName
}

enumeration ServiceMultiplicity
{
    ONE,
    MANY,
}

enumeration Verb
{
    GET,
    POST,
    PUT,
    PATCH,
    DELETE,
}

class Service
    transient
{
    className          : String key;
    urlString          : String key;
    verb               : Verb key;
    serviceMultiplicity: ServiceMultiplicity;
}

class Url
    transient
{
    className          : String key;
    url                : String key;
}

class ServiceGroup
    transient
{
    className          : String key;
}

association ServiceGroupHasClass
{
    serviceGroup: ServiceGroup[0..1];
    owningClass: Class[1..1];

    relationship this.className == Class.name
}

association ServiceGroupHasUrls
{
    serviceGroup: ServiceGroup[1..1];
    urls: Url[1..*];

    relationship this.className == Url.className
}

association UrlHasServices
{
    url: Url[1..1];
    services: Service[1..*];

    relationship this.className == Service.className && this.url == Service.urlString
}

projection ClassReadProjection on Class
{
    name                 : "Class name",
    inferred             : "Class inferred",
    packageName          : "Class package name",
    ordinal              : "Class ordinal",
    classModifiers       :
    {
        name    : "Class modifier name",
        inferred: "Class modifier inferred",
        ordinal : "Class modifier ordinal",
    },
    primitiveProperties  :
    {
        name                      : "Primitive property name",
        inferred                  : "Primitive property inferred",
        primitiveType             : "Primitive property type",
        optional                  : "Primitive property is optional",
        key                       : "Primitive property is key",
        id                        : "Primitive property is id",
        ordinal                   : "Primitive property ordinal",
        primitivePropertyModifiers:
        {
            name    : "Primitive property modifier name",
            inferred: "Primitive property modifier inferred",
            ordinal : "Primitive property modifier ordinal",
        },
    },
    enumerationProperties:
    {
        name                        : "Enumeration property name",
        inferred                    : "Enumeration property inferred",
        optional                    : "Enumeration property is optional",
        key                         : "Enumeration property is key",
        ordinal                     : "Enumeration property ordinal",
        enumeration                 :
        {
            name    : "Enumeration name",
            inferred: "Enumeration inferred",
        },
        enumerationPropertyModifiers:
        {
            name    : "Enumeration property modifier name",
            inferred: "Enumeration property inferred",
            ordinal : "Enumeration property modifier ordinal",
        },
    },
    associationEnds      :
    {
        name                   : "Association end name",
        inferred               : "Association end inferred",
        direction              : "Association end direction",
        multiplicity           : "Association end multiplicity",
        resultType             :
        {
            name: "Association end result type name",
        },
        owningAssociation      :
        {
            name: "Association end owning association name",
        },
        associationEndModifiers:
        {
            name    : "Association end modifier name",
            inferred: "Association end modifier inferred",
            ordinal : "Association end modifier ordinal",
        },
    },
}

service Class
{
    /api/meta/class/{className: String[1..1]}
        GET
        {
            multiplicity: one;
            criteria    : this.name == className;
            projection  : ClassReadProjection;
        }
    /api/meta/class
        GET
        {
            multiplicity: many;
            criteria    : all;
            projection  : ClassReadProjection;
        }
}
