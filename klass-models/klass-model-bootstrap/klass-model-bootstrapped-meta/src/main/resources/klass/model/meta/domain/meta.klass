package klass.model.meta.domain

interface Element
{
    inferred: Boolean;
    sourceCode: String maximumLength(100000);
    sourceCodeWithInference: String maximumLength(100000);
}

interface NamedElement
    implements Element
{
    name: String key;
    ordinal: Integer;
}

interface PackageableElement implements NamedElement
{
    packageName: String;

    // fullyQualifiedName: String = packageName + "." + name;
}

class Enumeration implements PackageableElement
{
}

class EnumerationLiteral implements NamedElement
{
    enumerationName               : String key;
    prettyName                    : String?;
}

association EnumerationHasLiterals
{
    enumeration: Enumeration[1..1];
    enumerationLiterals: EnumerationLiteral[1..*]
        orderBy: this.ordinal;

    relationship this.name == EnumerationLiteral.enumerationName
}

enumeration InheritanceType
{
    TABLE_PER_SUBCLASS("table-per-subclass"),
    TABLE_FOR_ALL_SUBCLASSES("table-for-all-subclasses"),
    TABLE_PER_CLASS("table-per-class"),
    NONE("none"),
}

// TODO: If key properties are present, may be table-per-class, otherwise table-per-subclass
// TODO: Ordinals should have a syntax and be inferred using macros
class Classifier
    abstract(table-per-class)
    implements PackageableElement
{
}

// TODO: Error when transient extends non-transient
class Interface
    extends Classifier
{
}

class ClassifierInterfaceMapping
{
    classifierName: String key private;
    interfaceName: String key private;
}

association ClassifierHasClassifierInterfaceMapping
{
    subClassifier: Classifier[1..1];
    superInterfaces               : ClassifierInterfaceMapping[0..*] owned;

    relationship this.name == ClassifierInterfaceMapping.classifierName
}

association ClassifierInterfaceMappingHasInterface
{
    superInterface                : Interface[1..1];
    subClassifiers                : ClassifierInterfaceMapping[0..*];

    relationship this.name == ClassifierInterfaceMapping.interfaceName
}

class Klass
    extends Classifier
{
    superClassName: String? private;
    inheritanceType: InheritanceType;
}

// TODO: Why isn't subClasses showing up in generated code? Reladomo bug?
association ClassHasSuperClass
{
    subClasses                    : Klass[0..*];
    superClass                    : Klass[0..1];

    // TODO: When this was backwards, I got a confusing error. How can I detect and prevent?
    relationship this.superClassName == Klass.name
}

enumeration PrimitiveType
{
    INTEGER("Integer"),
    LONG("Long"),
    DOUBLE("Double"),
    FLOAT("Float"),
    BOOLEAN("Boolean"),
    STRING("String"),
    INSTANT("Instant"),
    LOCAL_DATE("LocalDate"),
    TEMPORAL_INSTANT("TemporalInstant"),
    TEMPORAL_RANGE("TemporalRange"),
}

enumeration Multiplicity
{
    ZERO_TO_ONE("0..1"),
    ONE_TO_ONE("1..1"),
    ZERO_TO_MANY("0..*"),
    ONE_TO_MANY("1..*"),
}

class DataTypeProperty
    abstract(table-per-class)
    implements NamedElement
{
    classifierName                : String key;
    optional                      : Boolean;
    key                           : Boolean;
}

class PrimitiveProperty
    extends DataTypeProperty
{
    primitiveType                 : PrimitiveType;
    id                            : Boolean;
}

class EnumerationProperty
    extends DataTypeProperty
{
    enumerationName               : String private;
}

association EnumerationPropertyHasEnumeration
{
    enumerationProperty           : EnumerationProperty[0..*];
    enumeration                   : Enumeration[1..1];

    relationship this.enumerationName == Enumeration.name
}

// TODO: Change the orderBy syntax to orderBy(this.ordinal)
/*
association ClassifierHasDataTypeTypeProperties
{
    owningClassifier              : Classifier[1..1];
    dataTypeProperties            : DataTypeProperty[0..*] owned
        orderBy: this.ordinal;

    relationship this.name == DataTypeProperty.classifierName
}
*/

// TODO: Owned
association ClassifierHasPrimitiveProperties
{
    owningClassifier: Classifier[1..1];
    primitiveProperties: PrimitiveProperty[0..*]
        orderBy: this.ordinal;

    relationship this.name == PrimitiveProperty.classifierName
}

// TODO: Owned
association ClassifierHasEnumerationProperties
{
    owningClassifier: Classifier[1..1];
    enumerationProperties: EnumerationProperty[0..*]
        orderBy: this.ordinal;

    relationship this.name == EnumerationProperty.classifierName
}

interface PropertyValidation implements Element
{
}

class NumericPropertyValidation
    abstract(table-per-subclass)
    implements PropertyValidation
{
    classifierName                : String key;
    propertyName                  : String key;
    number: Integer;
}

class MinLengthPropertyValidation
    extends NumericPropertyValidation
{
}

class MaxLengthPropertyValidation
    extends NumericPropertyValidation
{
}

class MinPropertyValidation
    extends NumericPropertyValidation
{
}

class MaxPropertyValidation
    extends NumericPropertyValidation
{
}

association DataTypePropertyHasMinLengthPropertyValidation
{
    dataTypeProperty              : DataTypeProperty[1..1];
    minLengthValidation           : MinLengthPropertyValidation[0..1];

    relationship this.classifierName == MinLengthPropertyValidation.classifierName
            && this.name == MinLengthPropertyValidation.propertyName
}

association DataTypePropertyHasMaxLengthPropertyValidation
{
    dataTypeProperty              : DataTypeProperty[1..1];
    maxLengthValidation           : MaxLengthPropertyValidation[0..1];

    relationship this.classifierName == MaxLengthPropertyValidation.classifierName
            && this.name == MaxLengthPropertyValidation.propertyName
}

association PrimitivePropertyHasMinPropertyValidation
{
    primitiveProperty             : PrimitiveProperty[1..1];
    minValidation                 : MinPropertyValidation[0..1];

    relationship this.classifierName == MinPropertyValidation.classifierName
            && this.name == MinPropertyValidation.propertyName
}

association PrimitivePropertyHasMaxPropertyValidation
{
    primitiveProperty             : PrimitiveProperty[1..1];
    maxValidation                 : MaxPropertyValidation[0..1];

    relationship this.classifierName == MaxPropertyValidation.classifierName
            && this.name == MaxPropertyValidation.propertyName
}

class PropertyModifier
    implements NamedElement
{
    classifierName                : String key;
    propertyName                  : String key;
}

association DataTypePropertyHasModifiers
{
    dataTypeProperty              : DataTypeProperty[1..1];
    propertyModifiers             : PropertyModifier[0..*]
        orderBy: this.ordinal;

    relationship this.classifierName == PropertyModifier.classifierName
            && this.name == PropertyModifier.propertyName
}

class ClassifierModifier
    implements NamedElement
{
    classifierName: String key;
}

association ClassifierHasModifiers
{
    owningClassifier: Classifier[1..1];
    classifierModifiers: ClassifierModifier[0..*]
        orderBy: this.ordinal;

    relationship this.name == ClassifierModifier.classifierName
}

enumeration AssociationEndDirection
{
    SOURCE("source"),
    TARGET("target"),
}

class Association implements PackageableElement
{
    criteriaId: Long private;

    source(): AssociationEnd[1..1]
    {
        this.name == AssociationEnd.associationName
            && AssociationEnd.direction == AssociationEndDirection.SOURCE
    }

    target(): AssociationEnd[1..1]
    {
        this.name == AssociationEnd.associationName
            && AssociationEnd.direction == AssociationEndDirection.TARGET
    }
}

class AssociationEnd implements NamedElement
{
    owningClassName               : String key private;
    associationName               : String;
    direction                     : AssociationEndDirection;
    multiplicity                  : Multiplicity;
    resultTypeName                : String private;
}

// TODO: Consider moving the foreign keys onto Association (sourceClassName, sourceName, targetClassName, targetClass)
// simplification, ideally we'd model an association as having exactly two ends
association AssociationHasEnds
{
    owningAssociation: Association[1..1];
    associationEnds: AssociationEnd[0..*]
        orderBy: this.direction;

    relationship this.name == AssociationEnd.associationName
}

association ClassHasAssociationEnds
{
    owningClass: Klass[1..1];
    associationEnds: AssociationEnd[0..*];
    // TODO: Order by this.owningAssociation.ordinal

    relationship this.name == AssociationEnd.owningClassName
}

association AssociationEndHasResultType
{
    associationEndsResultTypeOf: AssociationEnd[0..*];
    resultType: Klass[1..1];

    relationship this.resultTypeName == Klass.name
}

class AssociationEndModifier
    implements NamedElement
{
    owningClassName               : String key;
    associationEndName            : String key;
}

association AssociationEndHasModifiers
{
    associationEnd: AssociationEnd[1..1];
    associationEndModifiers: AssociationEndModifier[0..*]
        orderBy: this.ordinal;

    relationship this.owningClassName == AssociationEndModifier.owningClassName
            && this.name == AssociationEndModifier.associationEndName
}

association AssociationHasCriteria
{
    association: Association[0..1];
    criteria: Criteria[1..1];

    relationship this.criteriaId == Criteria.id
}

enumeration Operator
{
    EQUALS("=="),
    NOT_EQUALS("!="),
    LESS_THAN("<"),
    GREATER_THAN(">"),
    LESS_THAN_EQUAL("<="),
    GREATER_THAN_EQUAL(">="),
    IN("in"),
    CONTAINS("contains"),
    STARTS_WITH("startsWith"),
    ENDS_WITH("endsWith"),
}

class Criteria
    abstract(table-per-class)
    implements Element
{
    id: Long id key;
}

class AllCriteria
    extends Criteria
{
}

class BinaryCriteria
    abstract(table-per-class)
    extends Criteria
{
    leftId        : Long private;
    rightId       : Long private;
}

class AndCriteria
    extends BinaryCriteria
{
}

class OrCriteria
    extends BinaryCriteria
{
}

class OperatorCriteria
    extends Criteria
{
    operator: Operator;
    sourceExpressionId: Long private;
    targetExpressionId: Long private;
}

class EdgePointCriteria
    extends Criteria
{
    memberReferencePathId: Long private;
}

association OperatorCriteriaHasSourceExpressionValue
{
    operatorCriteriaSourceOf: OperatorCriteria[0..1];
    sourceExpressionValue: ExpressionValue[1..1];

    relationship this.sourceExpressionId == ExpressionValue.id
}

association OperatorCriteriaHasTargetExpressionValue
{
    operatorCriteriaTargetOf: OperatorCriteria[0..1];
    targetExpressionValue: ExpressionValue[1..1];

    relationship this.targetExpressionId == ExpressionValue.id
}

association MemberReferencePathHasEdgePointCriteria
{
    memberReferencePath: MemberReferencePath[1..1];
    edgePointCriteria: EdgePointCriteria[1..1] owned;

    relationship this.id == EdgePointCriteria.memberReferencePathId
}

class ExpressionValue
    abstract(table-per-class)
{
    id      : Long key id;
}

class MemberReferencePath
    abstract(table-per-class)
    extends ExpressionValue
{
    className: String private;
    propertyClassName: String private;
    propertyName: String private;
}

association MemberReferencePathHasClass
{
    memberReferencePaths: MemberReferencePath[0..*];
    klass: Klass[1..1];

    relationship this.className == Klass.name
}

class MemberReferencePathAssociationEndMapping
{
    memberReferencePathId: Long key private;
    associationOwningClassName: String key private;
    associationEndName: String key private;
}

association MemberReferencePathHasMemberReferencePathAssociationEndMapping
{
    memberReferencePath: MemberReferencePath[1..1];
    associationEnds: MemberReferencePathAssociationEndMapping[0..*];

    relationship this.id == MemberReferencePathAssociationEndMapping.memberReferencePathId
}

association MemberReferencePathAssociationEndMappingHasAssociationEnd
{
    memberReferencePaths: MemberReferencePathAssociationEndMapping[0..*];
    associationEnd: AssociationEnd[1..1];

    relationship this.associationOwningClassName == AssociationEnd.owningClassName
            && this.associationEndName == AssociationEnd.name
}

// TODO: These associations only work in one direction
association DataTypePropertyHasMemberReferencePaths
{
    memberReferencePaths: MemberReferencePath[0..*];
    dataTypeProperty: DataTypeProperty[1..1];

    relationship this.propertyClassName == DataTypeProperty.classifierName
            && this.propertyName == DataTypeProperty.name
}

class ThisMemberReferencePath
    extends MemberReferencePath
{

}

class TypeMemberReferencePath
    extends MemberReferencePath
{
}

association BinaryCriteraHasLeft
{
    ownerOfLeftCriteria : BinaryCriteria[0..1];
    left                : Criteria[1..1];

    relationship this.leftId == Criteria.id
}

association BinaryCriteraHasRight
{
    ownerOfRightCriteria: BinaryCriteria[0..1];
    right               : Criteria[1..1];

    relationship this.rightId == Criteria.id
}

class ParameterizedProperty
    implements NamedElement
{
    owningClassName               : String key private;
    multiplicity                  : Multiplicity;
    resultTypeName                : String private;
}

association ClassHasParameterizedProperties
{
    owningClass: Klass[1..1];
    parameterizedProperties: ParameterizedProperty[0..*] owned
        orderBy: this.ordinal;

    relationship this.name == ParameterizedProperty.owningClassName
}

association ParameterizedPropertyHasResultType
{
    parameterizedPropertiesResultTypeOf: ParameterizedProperty[0..*];
    resultType: Klass[1..1];

    relationship this.resultTypeName == Klass.name
}

class AssociationEndOrdering
{
    associationName               : String key private;
    name                          : String;
    inferred                      : Boolean;
    multiplicity                  : Multiplicity;
    direction                     : AssociationEndDirection key;
    orderingId                    : Long private;
}

class ParameterizedPropertyOrdering
{
    owningClassName               : String private key;
    name                          : String key;
    inferred                      : Boolean;
    orderingId                    : Long private;
}

association AssociationEndHasOrdering
{
    associationEnd: AssociationEnd[1..1];
    associationEndOrdering: AssociationEndOrdering[0..1] owned;

    relationship this.associationName == AssociationEndOrdering.associationName
            && this.direction == AssociationEndOrdering.direction
}

association ParameterizedPropertyHasOrdering
{
    parameterizedProperty: ParameterizedProperty[1..1];
    parameterizedPropertyOrdering: ParameterizedPropertyOrdering[0..*];

    relationship this.owningClassName == ParameterizedPropertyOrdering.owningClassName
            && this.name == ParameterizedPropertyOrdering.name
}

/*
association AssociationEndOrderingHasParts
{
    associationEndOrdering: AssociationEndOrdering[1..1];
    ordering: Ordering[1..*];

    relationship this.orderingId == Ordering.id
}

association ParameterizedPropertyOrderingHasParts
{
    parameterizedPropertyOrdering: ParameterizedPropertyOrdering[1..1] owned;
    ordering: Ordering[1..1];

    // TODO: error when there's no "this"
    // relationship ParameterizedPropertyOrdering.orderingId == Ordering.id
    // TODO: error when the foreign key for a to-many is its entire primary key
    // relationship ParameterizedPropertyOrdering.orderingId == Ordering.id
    relationship this.orderingId == Ordering.id
}

class Ordering
{
    id                            : Long id key;
    inferred                      : Boolean;
}

// Split into data type / enum type order bys?
class OrderingPart
{
    orderingId                    : Long key;
    inferred                      : Boolean;

    // TODO: order keyword for properties meant for sorting?
    ordinal                       : Integer key;
    className                     : String private;
    propertyName                  : String private;
    direction                     : OrderingDirection;
}

association OrderingHasParts
{
    ordering: Ordering[1..1];
    orderingParts: OrderingPart[1..*]
        orderBy: this.ordinal;

    relationship this.id == OrderingPart.orderingId
}

enumeration OrderingDirection
{
    ASCENDING("ascending"),
    DESCENDING("descending"),
}

association OrderingPartHasDataTypeProperty
{
    orderingParts: OrderingPart[0..*];
    dataTypeProperty: PrimitiveProperty[1..1];

    relationship this.className == PrimitiveProperty.className
            && this.propertyName == PrimitiveProperty.name
}

association OrderingPartHasEnumerationProperty
{
    orderingParts: OrderingPart[0..*];
    enumerationProperty: EnumerationProperty[1..1];

    relationship this.className == EnumerationProperty.className
            && this.propertyName == EnumerationProperty.name
}
*/

association ParameterizedPropertyHasParameters
{
    parameterizedProperty         : ParameterizedProperty[1..1];
    parameters                    : ParameterizedPropertyParameter[0..*];

    relationship this.owningClassName == ParameterizedPropertyParameter.classifierName
            && this.name == ParameterizedPropertyParameter.parameterizedPropertyName
}

class ParameterizedPropertyParameter implements NamedElement
{
    classifierName                : String key private;
    parameterizedPropertyName     : String key;
}

/*
association ParameterizedPropertyHasCriteria
{
}
*/

enumeration ServiceMultiplicity
{
    ONE,
    MANY,
}

enumeration Verb
{
    GET,
    POST,
    PUT,
    PATCH,
    DELETE,
}

class Service
{
    className                     : String key;
    urlString                     : String key;
    verb                          : Verb key;
    serviceMultiplicity: ServiceMultiplicity;
}

class Url
{
    className          : String key;
    url                : String key;
}

class ServiceGroup
{
    className          : String key;
}

association ServiceGroupHasClass
{
    serviceGroup: ServiceGroup[0..1];
    owningClass: Klass[1..1];

    relationship this.className == Klass.name
}

association ServiceGroupHasUrls
{
    serviceGroup: ServiceGroup[1..1];
    urls: Url[1..*];

    relationship this.className == Url.className
}

association UrlHasServices
{
    url: Url[1..1];
    services: Service[1..*];

    relationship this.className == Service.className
            && this.url == Service.urlString
}

projection EnumerationProjection on Enumeration
{
    name                   : "Enumeration name",
    inferred               : "Enumeration inferred",
    packageName            : "Enumeration package name",
    ordinal                : "Enumeration ordinal",
    sourceCode             : "Enumeration sourceCode",
    sourceCodeWithInference: "Enumeration sourceCodeWithInference",
    enumerationLiterals    :
    {
        name                   : "Enumeration literal name",
        prettyName             : "Enumeration literal pretty name",
        inferred               : "Enumeration literal inferred",
        ordinal                : "Enumeration literal ordinal",
        sourceCode             : "Enumeration literal sourceCode",
        sourceCodeWithInference: "Enumeration literal sourceCodeWithInference",
    },
}

projection EnumerationSummaryProjection on Enumeration
{
    name               : "Enumeration name",
    packageName        : "Enumeration package name",
    enumerationLiterals:
    {
        name      : "Enumeration literal name",
        prettyName: "Enumeration literal pretty name",
    },
}

service Enumeration
{
    /api/meta/enumeration/{enumerationName: String[1..1]}
        GET
        {
            multiplicity: one;
            criteria    : this.name == enumerationName;
            projection  : EnumerationProjection;
        }
    /api/meta/enumeration/{enumerationName: String[1..1]}/summary
        GET
        {
            multiplicity: one;
            criteria    : this.name == enumerationName;
            projection  : EnumerationSummaryProjection;
        }
    /api/meta/enumeration
        GET
        {
            multiplicity: many;
            criteria    : all;
            projection  : EnumerationSummaryProjection;
            orderBy     : this.ordinal;
        }
}

projection InterfaceProjection on Interface
{
    name                   : "Interface name",
    inferred               : "Interface inferred",
    packageName            : "Interface package name",
    ordinal                : "Interface ordinal",
    sourceCode             : "Interface source code",
    sourceCodeWithInference: "Interface source code with inference",

    // TODO: flat many-to-many, or parameterized property
    superInterfaces        :
    {
        superInterface:
        {
            name           : "Super interface name",
            packageName    : "Super interface package name",
            superInterfaces:
            {
                superInterface:
                {
                    name       : "Super Super interface name",
                    packageName: "Super Super interface package name",
                },
            },
        },
    },
    classifierModifiers    :
    {
        name    : "Interface modifier name",
        inferred: "Interface modifier inferred",
        ordinal : "Interface modifier ordinal",
    },
    primitiveProperties    :
    {
        name               : "Primitive property name",
        inferred           : "Primitive property inferred",
        primitiveType      : "Primitive property type",
        optional           : "Primitive property is optional",
        key                : "Primitive property is key",
        id                 : "Primitive property is id",
        ordinal            : "Primitive property ordinal",
        propertyModifiers  :
        {
            name    : "Primitive property modifier name",
            inferred: "Primitive property modifier inferred",
            ordinal : "Primitive property modifier ordinal",
        },
        minLengthValidation:
        {
            number: "Min length validation number",
        },
        maxLengthValidation:
        {
            number: "Max length validation number",
        },
        minValidation      :
        {
            number: "Min validation number",
        },
        maxValidation      :
        {
            number: "Max validation number",
        },
    },
    enumerationProperties  :
    {
        name               : "Enumeration property name",
        inferred           : "Enumeration property inferred",
        optional           : "Enumeration property is optional",
        key                : "Enumeration property is key",
        ordinal            : "Enumeration property ordinal",
        enumeration        :
        {
            name    : "Enumeration name",
            inferred: "Enumeration inferred",
        },
        propertyModifiers  :
        {
            name    : "Enumeration property modifier name",
            inferred: "Enumeration property inferred",
            ordinal : "Enumeration property modifier ordinal",
        },
        minLengthValidation:
        {
            number: "Min length validation number",
        },
        maxLengthValidation:
        {
            number: "Max length validation number",
        },
    },
}

projection InterfaceSummaryProjection on Interface
{
    name                   : "Interface name",
    packageName            : "Interface package name",
    superInterfaces        :
    {
        superInterface:
        {
            name           : "Super interface name",
        },
    },
    classifierModifiers    :
    {
        name    : "Interface modifier name",
    },
    primitiveProperties    : PrimitivePropertySummaryProjection,
    enumerationProperties  : EnumerationPropertySummaryProjection,
}

service Interface
{
    /api/meta/interface/{interfaceName: String[1..1]}
        GET
        {
            multiplicity: one;
            criteria    : this.name == interfaceName;
            projection  : InterfaceProjection;
        }
    /api/meta/interface/{interfaceName: String[1..1]}/summary
        GET
        {
            multiplicity: one;
            criteria    : this.name == interfaceName;
            projection  : InterfaceSummaryProjection;
        }
    /api/meta/interface
        GET
        {
            multiplicity: many;
            criteria    : all;
            projection  : InterfaceSummaryProjection;
            orderBy     : this.ordinal;
        }
}

projection DataTypePropertyProjection on DataTypeProperty
{
    name                           : "Property name",
    inferred                       : "Property inferred",
    PrimitiveProperty.primitiveType: "Property primitive type",
    optional                       : "Property is optional",
    key                            : "Property is key",
    PrimitiveProperty.id           : "Property is id",
    ordinal                        : "Property ordinal",
    EnumerationProperty.enumeration:
    {
        name    : "Property Enumeration name",
        inferred: "Property Enumeration inferred",
    },
    propertyModifiers              :
    {
        name    : "Property modifier name",
        inferred: "Property modifier inferred",
        ordinal : "Property modifier ordinal",
    },
    minLengthValidation            :
    {
        number: "Property min length validation number",
    },
    maxLengthValidation            :
    {
        number: "Property max length validation number",
    },
    PrimitiveProperty.minValidation:
    {
        number: "Property min validation number",
    },
    PrimitiveProperty.maxValidation:
    {
        number: "Property max validation number",
    },
}

projection PrimitivePropertyProjection on PrimitiveProperty
{
    name               : "Primitive property name",
    inferred           : "Primitive property inferred",
    primitiveType      : "Primitive property type",
    optional           : "Primitive property is optional",
    key                : "Primitive property is key",
    id                 : "Primitive property is id",
    ordinal            : "Primitive property ordinal",
    propertyModifiers  :
    {
        name    : "Primitive property modifier name",
        inferred: "Primitive property modifier inferred",
        ordinal : "Primitive property modifier ordinal",
    },
    minLengthValidation:
    {
        number: "Min length validation number",
    },
    maxLengthValidation:
    {
        number: "Max length validation number",
    },
    minValidation      :
    {
        number: "Min validation number",
    },
    maxValidation      :
    {
        number: "Max validation number",
    },
}

projection PrimitivePropertySummaryProjection on PrimitiveProperty
{
    name               : "Primitive property name",
    primitiveType      : "Primitive property type",
    optional           : "Primitive property is optional",
    key                : "Primitive property is key",
    id                 : "Primitive property is id",
    propertyModifiers  :
    {
        name    : "Primitive property modifier name",
    },
    minLengthValidation:
    {
        number: "Min length validation number",
    },
    maxLengthValidation:
    {
        number: "Max length validation number",
    },
    minValidation      :
    {
        number: "Min validation number",
    },
    maxValidation      :
    {
        number: "Max validation number",
    },
}

projection EnumerationPropertyProjection on EnumerationProperty
{
    name               : "Enumeration property name",
    inferred           : "Enumeration property inferred",
    optional           : "Enumeration property is optional",
    key                : "Enumeration property is key",
    ordinal            : "Enumeration property ordinal",
    enumeration        :
    {
        name    : "Enumeration name",
        inferred: "Enumeration inferred",
    },
    propertyModifiers  :
    {
        name    : "Enumeration property modifier name",
        inferred: "Enumeration property inferred",
        ordinal : "Enumeration property modifier ordinal",
    },
    minLengthValidation:
    {
        number: "Min length validation number",
    },
    maxLengthValidation:
    {
        number: "Max length validation number",
    },
}

projection EnumerationPropertySummaryProjection on EnumerationProperty
{
    name               : "Enumeration property name",
    optional           : "Enumeration property is optional",
    key                : "Enumeration property is key",
    enumeration        :
    {
        name    : "Enumeration name",
    },
    propertyModifiers  :
    {
        name    : "Enumeration property modifier name",
    },
    minLengthValidation:
    {
        number: "Min length validation number",
    },
    maxLengthValidation:
    {
        number: "Max length validation number",
    },
}

projection ClassProjection on Klass
{
    name                   : "Class name",
    inferred               : "Class inferred",
    packageName            : "Class package name",
    ordinal                : "Class ordinal",
    sourceCode             : "Class source code",
    sourceCodeWithInference: "Class source code with inference",
    superClass             :
    {
        name           : "Super Class name",
        packageName    : "Super Class package name",
        superClass     :
        {
            name       : "Super Super Class name",
            packageName: "Super Super Class package name",
        },

        // TODO: flat many-to-many, or parameterized property
        superInterfaces:
        {
            superInterface:
            {
                name       : "Super Class Super Interface name",
                packageName: "Super Class Super Interface package name",
            },
        },
    },

    // TODO: flat many-to-many, or parameterized property
    superInterfaces        :
    {
        superInterface:
        {
            name           : "Super interface name",
            packageName    : "Super interface package name",
            superInterfaces:
            {
                superInterface:
                {
                    name       : "Super Super interface name",
                    packageName: "Super Super interface package name",
                },
            },
        },
    },
    /*
    subClasses         :
    {
        name       : "Sub Class name",
        packageName: "Sub Class package name",
    },
    */
    classifierModifiers    :
    {
        name    : "Class modifier name",
        inferred: "Class modifier inferred",
        ordinal : "Class modifier ordinal",
    },
    primitiveProperties    : PrimitivePropertyProjection,
    enumerationProperties  : EnumerationPropertyProjection,
    associationEnds        : AssociationEndProjection,
}

projection ClassSummaryProjection on Klass
{
    name                   : "Class name",
    packageName            : "Class package name",
    superClass             :
    {
        name           : "Super Class name",
    },

    // TODO: flat many-to-many, or parameterized property
    superInterfaces        :
    {
        superInterface:
        {
            name           : "Super interface name",
        },
    },
    classifierModifiers    :
    {
        name    : "Class modifier name",
    },
    primitiveProperties    : PrimitivePropertySummaryProjection,
    enumerationProperties  : EnumerationPropertySummaryProjection,
}

service Klass
{
    /api/meta/class/{className: String[1..1]}
        GET
        {
            multiplicity: one;
            criteria    : this.name == className;
            projection  : ClassProjection;
        }
    /api/meta/class/{className: String[1..1]}/summary
        GET
        {
            multiplicity: one;
            criteria    : this.name == className;
            projection  : ClassSummaryProjection;
        }
    /api/meta/class
        GET
        {
            multiplicity: many;
            criteria    : all;
            projection  : ClassSummaryProjection;
            orderBy     : this.ordinal;
        }
}

projection ClassifierSummaryProjection on Classifier
{
    name                   : "Classifier name",
    packageName            : "Classifier package name",
    Klass.superClass             :
    {
        name           : "Super Class name",
    },

    // TODO: flat many-to-many, or parameterized property
    superInterfaces        :
    {
        superInterface:
        {
            name           : "Super interface name",
        },
    },
    classifierModifiers    :
    {
        name    : "Classifier modifier name",
    },
    primitiveProperties    : PrimitivePropertySummaryProjection,
    enumerationProperties  : EnumerationPropertySummaryProjection,
}

service Classifier
{
    /api/meta/classifier/{classifierName: String[1..1]}
        GET
        {
            multiplicity: one;
            criteria    : this.name == classifierName;
            projection  : ClassifierSummaryProjection;
        }
    /api/meta/classifier
        GET
        {
            multiplicity: many;
            criteria    : all;
            projection  : ClassifierSummaryProjection;
            orderBy     : this.ordinal;
        }
}

projection AssociationEndProjection on AssociationEnd
{
    name                   : "Association end name",
    inferred               : "Association end inferred",
    ordinal                : "Association end ordinal",
    sourceCode             : "Association end source code",
    sourceCodeWithInference: "Association end sourceCodeWithInference",
    direction              : "Association end direction",
    multiplicity           : "Association end multiplicity",
    owningClass            :
    {
        name       : "Association end owning class name",
        packageName: "Association end owning class package name",
    },
    resultType             :
    {
        name       : "Association end result class name",
        packageName: "Association end result class package name",
    },
    owningAssociation      :
    {
        name: "Association end owning association name",
    },
    associationEndModifiers:
    {
        name    : "Association end modifier name",
        inferred: "Association end modifier inferred",
        ordinal : "Association end modifier ordinal",
    },
}

projection AssociationEndSummaryProjection on AssociationEnd
{
    name                   : "Association end name",
    multiplicity           : "Association end multiplicity",
    resultType             :
    {
        name       : "Association end result class name",
    },
    associationEndModifiers:
    {
        name    : "Association end modifier name",
    },
}

projection AssociationProjection on Association
{
    name                   : "Association name",
    inferred               : "Association inferred",
    packageName            : "Association package name",
    ordinal                : "Association ordinal",
    sourceCode             : "Association source code",
    sourceCodeWithInference: "Association sourceCodeWithInference",
    associationEnds        : AssociationEndProjection,
    criteria               : CriteriaProjection,
}

projection AssociationSummaryProjection on Association
{
    name                   : "Association name",
    packageName            : "Association package name",
    associationEnds        : AssociationEndSummaryProjection,
    criteria               : CriteriaSummaryProjection,
}

projection MemberReferencePathProjection on MemberReferencePath
{
    klass           :
    {
        name: "MemberReferencePath Class name",
    },
    associationEnds :
    {
        associationEnd:
        {
            name: "MemberReferencePath Association end name",
        },
    },
    dataTypeProperty:
    {
        name: "MemberReferencePath Property name",
    },
}

projection MemberReferencePathSummaryProjection on MemberReferencePath
{
    klass           :
    {
        name: "MemberReferencePath Class name",
    },
    associationEnds :
    {
        associationEnd:
        {
            name: "MemberReferencePath Association end name",
        },
    },
    dataTypeProperty:
    {
        name: "MemberReferencePath Property name",
    },
}

projection ExpressionValueProjection on ExpressionValue
{
    MemberReferencePath.klass           :
    {
        name: "MemberReferencePath Class name",
    },
    MemberReferencePath.associationEnds :
    {
        associationEnd:
        {
            name: "MemberReferencePath Association end name",
        },
    },
    MemberReferencePath.dataTypeProperty:
    {
        name: "MemberReferencePath Property name",
    },
}

projection ExpressionValueSummaryProjection on ExpressionValue
{
    MemberReferencePath.klass           :
    {
        name       : "MemberReferencePath Class name",
    },
    MemberReferencePath.associationEnds :
    {
        associationEnd:
        {
            name        : "MemberReferencePath Association end name",
        },
    },
    MemberReferencePath.dataTypeProperty:
    {
        name                           : "MemberReferencePath Property name",
    },
}

projection CriteriaProjection on Criteria
{
    BinaryCriteria.left                   : CriteriaProjection,
    BinaryCriteria.right                  : CriteriaProjection,
    OperatorCriteria.operator             : "Criteria operator",
    OperatorCriteria.sourceExpressionValue: ExpressionValueProjection,
    OperatorCriteria.targetExpressionValue: ExpressionValueProjection,
    EdgePointCriteria.memberReferencePath : MemberReferencePathProjection,
}

projection CriteriaSummaryProjection on Criteria
{
    BinaryCriteria.left                   : CriteriaSummaryProjection,
    BinaryCriteria.right                  : CriteriaSummaryProjection,
    OperatorCriteria.operator             : "Criteria operator",
    OperatorCriteria.sourceExpressionValue: ExpressionValueSummaryProjection,
    OperatorCriteria.targetExpressionValue: ExpressionValueSummaryProjection,
    EdgePointCriteria.memberReferencePath : MemberReferencePathSummaryProjection,
}

service Association
{
    /api/meta/association/{associationName: String[1..1]}
        GET
        {
            multiplicity: one;
            criteria    : this.name == associationName;
            projection  : AssociationProjection;
        }
    /api/meta/association/{associationName: String[1..1]}/summary
        GET
        {
            multiplicity: one;
            criteria    : this.name == associationName;
            projection  : AssociationSummaryProjection;
        }
    /api/meta/association
        GET
        {
            multiplicity: many;
            criteria    : all;
            projection  : AssociationSummaryProjection;
        }
}
