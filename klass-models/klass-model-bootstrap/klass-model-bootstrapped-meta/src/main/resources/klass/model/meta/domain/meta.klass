package klass.model.meta.domain

interface Element
{
    inferred: Boolean;
    sourceCode: String maximumLength(100000);
    sourceCodeWithInference: String maximumLength(100000);
}

interface NamedElement
    implements Element
{
    name: String;
    ordinal: Integer;
}

interface PackageableElement
{
    packageName: String;

    // fullyQualifiedName: String = packageName + "." + name;
}

// TODO: If key properties are present, may be table-per-class, otherwise table-per-subclass
class Classifier
    abstract(table-per-class)
    implements PackageableElement
{
    name: String key;
    inferred: Boolean;
    packageName: String;

    // TODO: Ordinals should have a syntax and be inferred using macros
    ordinal: Integer;
    sourceCode: String maximumLength(100000);
}

// TODO: Error when transient extends non-transient
class Interface
    extends Classifier
{
}

class ClassifierInterfaceMapping
{
    classifierName: String key private;
    interfaceName: String key private;
}

association ClassifierHasClassifierInterfaceMapping
{
    subClassifier: Classifier[1..1];
    superInterfaces: ClassifierInterfaceMapping[0..*] owned;

    relationship this.name == ClassifierInterfaceMapping.classifierName
}

association ClassifierInterfaceMappingHasInterface
{
    superInterface: Interface[1..1];
    subClassifiers: ClassifierInterfaceMapping[0..*];

    relationship this.name == ClassifierInterfaceMapping.interfaceName
}

class Klass
    extends Classifier
{
    superClassName: String? private;
}

association ClassHasSuperClass
{
    subClasses: Klass[0..*];
    superClass: Klass[0..1];

    relationship this.superClassName == Klass.name
}

enumeration PrimitiveType
{
    INTEGER("Integer"),
    LONG("Long"),
    DOUBLE("Double"),
    FLOAT("Float"),
    BOOLEAN("Boolean"),
    STRING("String"),
    INSTANT("Instant"),
    LOCAL_DATE("LocalDate"),
    TEMPORAL_INSTANT("TemporalInstant"),
    TEMPORAL_RANGE("TemporalRange"),
}

enumeration Multiplicity
{
    ZERO_TO_ONE("0..1"),
    ONE_TO_ONE("1..1"),
    ZERO_TO_MANY("0..*"),
    ONE_TO_MANY("1..*"),
}

class PrimitiveProperty
{
    className                     : String key;
    name                          : String key;
    inferred                      : Boolean;
    primitiveType                 : PrimitiveType;
    optional                      : Boolean;
    key                           : Boolean;
    id                            : Boolean;
    ordinal                       : Integer;
}

association ClassHasPrimitiveTypeProperties
{
    owningClass: Klass[1..1];
    primitiveProperties: PrimitiveProperty[0..*] owned

    // TODO: Change the orderBy syntax to orderBy(this.ordinal)
        orderBy: this.ordinal;

    relationship this.name == PrimitiveProperty.className
}

class Enumeration
{
    name                          : String key;
    inferred                      : Boolean;
    packageName                   : String private;
    ordinal                       : Integer;
    sourceCode                    : String maximumLength(100000);
}

class EnumerationLiteral
{
    enumerationName               : String key;
    name                          : String key;
    inferred                      : Boolean;
    prettyName                    : String?;
    ordinal                       : Integer;
}

association EnumerationHasLiterals
{
    enumeration: Enumeration[1..1];
    enumerationLiterals: EnumerationLiteral[1..*]
        orderBy: this.ordinal;

    relationship this.name == EnumerationLiteral.enumerationName
}

class EnumerationProperty
{
    className                     : String key;
    name                          : String key;
    inferred                      : Boolean;
    enumerationName               : String private;
    optional                      : Boolean;
    key                           : Boolean;
    ordinal                       : Integer;
}

association EnumerationPropertyHasEnumeration
{
    enumerationProperty: EnumerationProperty[0..*];
    enumeration: Enumeration[1..1];

    relationship this.enumerationName == Enumeration.name
}

association ClassHasEnumerationProperties
{
    owningClass: Klass[1..1];
    enumerationProperties: EnumerationProperty[0..*]
        orderBy: this.ordinal;

    relationship this.name == EnumerationProperty.className
}

class PrimitivePropertyModifier
{
    className                     : String key;
    propertyName                  : String key;
    name                          : String key;
    inferred                      : Boolean;
    ordinal                       : Integer;
}

class EnumerationPropertyModifier
{
    className                     : String key;
    propertyName                  : String key;
    name                          : String key;
    inferred                      : Boolean;
    ordinal                       : Integer;
}

association PrimitivePropertyHasModifiers
{
    primitiveProperty: PrimitiveProperty[1..1];
    primitivePropertyModifiers: PrimitivePropertyModifier[0..*]
        orderBy: this.ordinal;

    relationship this.className == PrimitivePropertyModifier.className
            && this.name == PrimitivePropertyModifier.propertyName
}

association EnumerationPropertyHasModifiers
{
    enumerationProperty: EnumerationProperty[1..1];
    enumerationPropertyModifiers: EnumerationPropertyModifier[0..*]
        orderBy: this.ordinal;

    relationship this.className == EnumerationPropertyModifier.className
            && this.name == EnumerationPropertyModifier.propertyName
}

class ClassModifier
{
    className                     : String key;
    name                          : String key;
    inferred                      : Boolean;
    ordinal                       : Integer;
}

association ClassHasModifiers
{
    owningClass: Klass[1..1];
    classModifiers: ClassModifier[0..*]
        orderBy: this.ordinal;

    relationship this.name == ClassModifier.className
}

enumeration AssociationEndDirection
{
    SOURCE("source"),
    TARGET("target"),
}

class Association
{
    name                          : String key;
    inferred                      : Boolean;
    packageName                   : String;
    ordinal                       : Integer;
    sourceCode                    : String maximumLength(100000);

    source(): AssociationEnd[1..1]
    {
        this.name == AssociationEnd.associationName
            && AssociationEnd.direction == AssociationEndDirection.SOURCE
    }

    target(): AssociationEnd[1..1]
    {
        this.name == AssociationEnd.associationName
            && AssociationEnd.direction == AssociationEndDirection.TARGET
    }
}

class AssociationEnd
{
    owningClassName               : String key private;
    name                          : String key;
    inferred                      : Boolean;
    associationName               : String;
    direction                     : AssociationEndDirection;
    multiplicity                  : Multiplicity;
    resultTypeName                : String private;
    ordinal                       : Integer;
}

// simplification, ideally we'd model an association as having exactly two ends
association AssociationHasEnds
{
    owningAssociation: Association[1..1];
    associationEnds: AssociationEnd[0..*]
        orderBy: this.direction;

    relationship this.name == AssociationEnd.associationName
}

association ClassHasAssociationEnds
{
    owningClass: Klass[1..1];
    associationEnds: AssociationEnd[0..*];
    // TODO: Order by this.owningAssociation.ordinal

    relationship this.name == AssociationEnd.owningClassName
}

association AssociationEndHasResultType
{
    associationEndsResultTypeOf: AssociationEnd[0..*];
    resultType: Klass[1..1];

    relationship this.resultTypeName == Klass.name
}

class AssociationEndModifier
{
    owningClassName               : String key;
    associationEndName            : String key;
    name                          : String key;
    inferred                      : Boolean;
    ordinal                       : Integer;
}

association AssociationEndHasModifiers
{
    associationEnd: AssociationEnd[1..1];
    associationEndModifiers: AssociationEndModifier[0..*]
        orderBy: this.ordinal;

    relationship this.owningClassName == AssociationEndModifier.owningClassName
            && this.name == AssociationEndModifier.associationEndName
}

class ParameterizedProperty
{
    owningClassName               : String key private;
    name                          : String key;
    inferred                      : Boolean;
    multiplicity                  : Multiplicity;
    resultTypeName                : String private;
    ordinal                       : Integer;
}

association ClassHasParameterizedProperties
{
    owningClass: Klass[1..1];
    parameterizedProperties: ParameterizedProperty[0..*] owned
        orderBy: this.ordinal;

    relationship this.name == ParameterizedProperty.owningClassName
}

association ParameterizedPropertyHasResultType
{
    parameterizedPropertiesResultTypeOf: ParameterizedProperty[0..*];
    resultType: Klass[1..1];

    relationship this.resultTypeName == Klass.name
}

class AssociationEndOrdering
{
    associationName               : String key private;
    name                          : String;
    inferred                      : Boolean;
    multiplicity                  : Multiplicity;
    direction                     : AssociationEndDirection key;
    orderingId                    : Long private;
}

class ParameterizedPropertyOrdering
{
    owningClassName               : String private key;
    name                          : String key;
    inferred                      : Boolean;
    orderingId                    : Long private;
}

association AssociationEndHasOrdering
{
    associationEnd: AssociationEnd[1..1];
    associationEndOrdering: AssociationEndOrdering[0..1] owned;

    relationship this.associationName == AssociationEndOrdering.associationName
            && this.direction == AssociationEndOrdering.direction
}

association ParameterizedPropertyHasOrdering
{
    parameterizedProperty: ParameterizedProperty[1..1];
    parameterizedPropertyOrdering: ParameterizedPropertyOrdering[0..*];

    relationship this.owningClassName == ParameterizedPropertyOrdering.owningClassName
            && this.name == ParameterizedPropertyOrdering.name
}

/*
association AssociationEndOrderingHasParts
{
    associationEndOrdering: AssociationEndOrdering[1..1];
    ordering: Ordering[1..*];

    relationship this.orderingId == Ordering.id
}

association ParameterizedPropertyOrderingHasParts
{
    parameterizedPropertyOrdering: ParameterizedPropertyOrdering[1..1] owned;
    ordering: Ordering[1..1];

    // TODO: error when there's no "this"
    // relationship ParameterizedPropertyOrdering.orderingId == Ordering.id
    // TODO: error when the foreign key for a to-many is its entire primary key
    // relationship ParameterizedPropertyOrdering.orderingId == Ordering.id
    relationship this.orderingId == Ordering.id
}

class Ordering
{
    id                            : Long id key;
    inferred                      : Boolean;
}

// Split into data type / enum type order bys?
class OrderingPart
{
    orderingId                    : Long key;
    inferred                      : Boolean;

    // TODO: order keyword for properties meant for sorting?
    ordinal                       : Integer key;
    className                     : String private;
    propertyName                  : String private;
    direction                     : OrderingDirection;
}

association OrderingHasParts
{
    ordering: Ordering[1..1];
    orderingParts: OrderingPart[1..*]
        orderBy: this.ordinal;

    relationship this.id == OrderingPart.orderingId
}

enumeration OrderingDirection
{
    ASCENDING("ascending"),
    DESCENDING("descending"),
}

association OrderingPartHasDataTypeProperty
{
    orderingParts: OrderingPart[0..*];
    dataTypeProperty: PrimitiveProperty[1..1];

    relationship this.className == PrimitiveProperty.className
            && this.propertyName == PrimitiveProperty.name
}

association OrderingPartHasEnumerationProperty
{
    orderingParts: OrderingPart[0..*];
    enumerationProperty: EnumerationProperty[1..1];

    relationship this.className == EnumerationProperty.className
            && this.propertyName == EnumerationProperty.name
}
*/

association ParameterizedPropertyHasParameters
{
    parameterizedProperty: ParameterizedProperty[1..1];
    parameters: ParameterizedPropertyParameter[0..*];

    relationship this.owningClassName == ParameterizedPropertyParameter.parameterizedPropertyClassName
            && this.name == ParameterizedPropertyParameter.parameterizedPropertyName
}

class ParameterizedPropertyParameter
{
    parameterizedPropertyClassName: String key private;
    parameterizedPropertyName     : String key;
    name                          : String;
    inferred                      : Boolean;
}

/*
association ParameterizedPropertyHasCriteria
{

}
*/

enumeration ServiceMultiplicity
{
    ONE,
    MANY,
}

enumeration Verb
{
    GET,
    POST,
    PUT,
    PATCH,
    DELETE,
}

class Service
{
    className          : String key;
    urlString          : String key;
    verb               : Verb key;
    serviceMultiplicity: ServiceMultiplicity;
}

class Url
{
    className          : String key;
    url                : String key;
}

class ServiceGroup
{
    className          : String key;
}

association ServiceGroupHasClass
{
    serviceGroup: ServiceGroup[0..1];
    owningClass: Klass[1..1];

    relationship this.className == Klass.name
}

association ServiceGroupHasUrls
{
    serviceGroup: ServiceGroup[1..1];
    urls: Url[1..*];

    relationship this.className == Url.className
}

association UrlHasServices
{
    url: Url[1..1];
    services: Service[1..*];

    relationship this.className == Service.className
            && this.url == Service.urlString
}

projection ClassReadProjection on Klass
{
    name                 : "Class name",
    inferred             : "Class inferred",
    packageName          : "Class package name",
    ordinal              : "Class ordinal",
    sourceCode           : "Class source code",
    superClass           :
    {
        name       : "Super Class name",
        packageName: "Super Class package name",
    },
    // TODO: flat many-to-many, or parameterized property
    superInterfaces      :
    {
        superInterface:
        {
            name       : "Class name",
            packageName: "Class package name",
        },
    },
    classModifiers       :
    {
        name    : "Class modifier name",
        inferred: "Class modifier inferred",
        ordinal : "Class modifier ordinal",
    },
    primitiveProperties  :
    {
        name                      : "Primitive property name",
        inferred                  : "Primitive property inferred",
        primitiveType             : "Primitive property type",
        optional                  : "Primitive property is optional",
        key                       : "Primitive property is key",
        id                        : "Primitive property is id",
        ordinal                   : "Primitive property ordinal",
        primitivePropertyModifiers:
        {
            name    : "Primitive property modifier name",
            inferred: "Primitive property modifier inferred",
            ordinal : "Primitive property modifier ordinal",
        },
    },
    enumerationProperties:
    {
        name                        : "Enumeration property name",
        inferred                    : "Enumeration property inferred",
        optional                    : "Enumeration property is optional",
        key                         : "Enumeration property is key",
        ordinal                     : "Enumeration property ordinal",
        enumeration                 :
        {
            name    : "Enumeration name",
            inferred: "Enumeration inferred",
        },
        enumerationPropertyModifiers:
        {
            name    : "Enumeration property modifier name",
            inferred: "Enumeration property inferred",
            ordinal : "Enumeration property modifier ordinal",
        },
    },
    associationEnds      :
    {
        name                   : "Association end name",
        inferred               : "Association end inferred",
        direction              : "Association end direction",
        multiplicity           : "Association end multiplicity",
        resultType             :
        {
            name: "Association end result type name",
        },
        owningAssociation      :
        {
            name: "Association end owning association name",
        },
        associationEndModifiers:
        {
            name    : "Association end modifier name",
            inferred: "Association end modifier inferred",
            ordinal : "Association end modifier ordinal",
        },
    },
}

service Klass
{
    /api/meta/class/{className: String[1..1]}
        GET
        {
            multiplicity: one;
            criteria    : this.name == className;
            projection  : ClassReadProjection;
        }
    /api/meta/class
        GET
        {
            multiplicity: many;
            criteria    : all;
            projection  : ClassReadProjection;
        }
}

projection AssociationReadProjection on Association
{
    name           : "Association name",
    inferred       : "Association inferred",
    packageName    : "Association package name",
    ordinal        : "Association ordinal",
    sourceCode     : "Association source code",
    associationEnds:
    {
        name        : "Association end name",
        inferred    : "Association end inferred",
        direction   : "Association end direction",
        multiplicity: "Association end multiplicity",
        ordinal     : "Association end ordinal",
        /*
        owningClass :
        {
            name       : "Association end owning class name",
            packageName: "Association end owning class package name",
        },
        */
        resultType  :
        {
            name       : "Association end result class name",
            packageName: "Association end result class package name",
        },
    },
}

service Association
{
    /api/meta/association/{associationName: String[1..1]}
        GET
        {
            multiplicity: one;
            criteria    : this.name == associationName;
            projection  : AssociationReadProjection;
        }
    /api/meta/association
        GET
        {
            multiplicity: many;
            criteria    : all;
            projection  : AssociationReadProjection;
        }
}
