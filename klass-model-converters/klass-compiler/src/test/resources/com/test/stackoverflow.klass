/*
 * Simplified StackOverflow domain model. One question has many answers.
 */
package com.stackoverflow

// 'user' is just a special class that represents logged in users
// There must only be a single user class in the model, it must have a single key, and the key must be of type String. Other properties must be nullable
user User
    read
{
    // `read` keyword with no projection means create read services with the default read projection
    // The default read projection includes just this class and all its properties
    key userId     : String

    // TODO: String max lengths
    firstName      : String?
    lastName       : String?
    email          : String?
}

enumeration Status
{
    OPEN("Open"),
    ON_HOLD("On hold"),
    CLOSED("Closed"),
}

class Question
    read(QuestionReadProjection)
    create(QuestionWriteProjection)
    update(QuestionWriteProjection)
    systemTemporal
    versioned
    audited
    optimisticallyLocked
{
    key id         : ID
    title          : String
    body           : String

    // TODO: Statemachine
    status         : Status
    deleted        : Boolean

    // TODO: Consider type inference on paramterized property parameters based on usage in relationship
    // orderBy natural key ascending is the default
    answersWithSubstring(substring: String[1..1]): Answer[0..*]
        orderBy: this.id ascending
    {
        this.id == Answer.questionId
            && Answer.body contains substring
    }

    activeAnswers(): Answer[0..*]
    {
        this.id == Answer.questionId
            && Answer.deleted == false
    }

    // These two properties are implied by systemTemporal, and are not supposed to actually be declared
    systemFrom     : Instant
    systemTo       : Instant

    // This isn't even a real property. It's referenced in criteria as a shorthand. For example Question.system == {time} is shorthand for Question.systemFrom <= {time} && Question.systemTo > {time}
    system         : Instant

    // These three properties and two parameterized properties are implied by audited, and are not supposed to actually be declared
    // They could automatically be part of read projections and not write projections
    createdById    : String

    // createdOn, or createdDate?
    createdOn      : Instant
    lastUpdatedById: String

    createdBy(): User[1..1]
    {
        this.createdById == User.userId
    }

    lastUpdatedBy(): User[1..1]
    {
        this.lastUpdatedById == User.userId
    }
}

// The _Version class is implied by the versioned annotation, and not supposed to actually be declared
class QuestionVersion
    systemTemporal
{
    // Key properties copied from Question
    key id         : ID

    // The version number
    // It gets incremented automatically when anything in the version project (QuestionWriteProjection) gets edited
    // TODO: Consider changing the primitive names to int32, int64, float32, float64, id32, id64
    number         : Integer
}

// The _HasVersion association is implied by the versioned annotation, and not supposed to actually be declared
// It could automatically be part of read projections and not write projections
association QuestionHasVersion
{
    question: Question[1..1]
    version: QuestionVersion[1..1]

    // implied
    relationship Question.id == QuestionVersion.id
            && Question.system == QuestionVersion.system
}

association QuestionHasAnswer
{
    question: Question[1..1]
    answers: Answer[0..*]
        orderBy: this.id ascending

    // ordering by primary key ascending is the default
    relationship Question.id == Answer.questionId
}

class Answer
    versioned
{
    key id         : ID
    body           : String
    deleted        : Boolean
    private questionId: Long
}

// TODO Model AnswerVote
// TODO Interface Vote
// TODO superclass AbstractVote
// TODO Aggregation for number of upvotes and downvotes
class QuestionVote
    systemTemporal
    audited
{
    key questionId: Long
    key createdById: String
    direction: VoteDirection
}

enumeration VoteDirection
{
    UP("up"),
    DOWN("down"),
}

// TODO: Projection inheritance? QuestionReadProjection extends QuestionWriteProjection
projection QuestionReadProjection on Question
{
    // field names are "includes", field values are column headers when serializing to a tabular format
    title  : "Question title",
    body   : "Question body",
    answers:
    {
        body: "Answer body",
    },
}

projection QuestionWriteProjection on Question
{
    title: "Question title",
    body : "Question body",
}

// TODO: Type inference on projection paramters
projection FilteredAnswersProjection(substring: String[1..1]) on Question
{
    title                          : "Question title",
    body                           : "Question body",
    answersWithSubstring(substring):
    {
        body: "Answer body",
    },
}

// Just embed inside the Question class?
service Question
{
    // TODO: matrix url params
    /api/question/{id: Long[1..1]}/{substring: String[1..1]}
        GET
        {
            multiplicity: many
            criteria    : this.id == id
            projection  : FilteredAnswersProjection(substring)
        }
    /api/question/{titleSubstring: String[1..1]}
        GET
        {
            multiplicity: many
            criteria    : this.title startsWith titleSubstring
            projection  : QuestionReadProjection
        }
    /api/question/{id: Long[1..1]}
        GET
        {
            multiplicity: one
            criteria    : this.id == id
            projection  : QuestionReadProjection
        }
    /api/question/in/{id: Long[0..*]}
        GET
        {
            multiplicity: one
            criteria    : this.id in id
            projection  : QuestionReadProjection
        }
    /api/question/firstTwo
        GET
        {
            multiplicity: one
            criteria    : this.id in (1, 2)
            projection  : QuestionReadProjection
        }
    /api/question/{id: Long[1..1]}?{version: Integer[1..1]}
        PUT
        {
            // PUT, PATCH, and DELETE should implicitly get ?version={version} due to optimistic locking
            multiplicity: one
            criteria    : this.id == id

            // TODO: Should differentiate between 'validate' 400 error and something like 'conflict' 409
            // Consider 412 Precondition Failed or 417 Expectation Failed instead of 400, and leave bad request for problems like invalid json, or mismatches with the meta model
        conflict        : this.id == QuestionVersion.id
                && QuestionVersion.number == version
            projection  : QuestionWriteProjection
        }
        DELETE
        {
            // PUT, PATCH, and DELETE should implicitly get ?version={version} due to optimistic locking
            multiplicity: one
            criteria    : this.id == id

            // 'authorize' is like 'validate' but should give 401 Unauthorized or 403 forbidden instead of 400
            // TODO: conditions implemented in code, like `|| native(UserIsModeratorClass)`
            authorize   : this.createdById == user

            // TODO: Should differentiate between 'validate' 400 error and something like 'conflict' 409
            validate    : this.id == QuestionVersion.id
                    && QuestionVersion.number == version
            projection  : QuestionWriteProjection
        }
    /api/question
        POST
        {
            multiplicity: one
            projection  : QuestionWriteProjection
        }
        GET
        {
            multiplicity: many
            criteria    : this.title startsWith "Why do"
            projection  : QuestionReadProjection
        }

    // TODO: Type inference on url parameters
    /api/user/{userId: String[1..1]}/questions
        GET
        {
            //?page=1&pageSize=25
            multiplicity: many
            criteria    : this.createdById == userId
            projection  : QuestionWriteProjection

            // Deliberately shallow
            orderBy     : this.createdOn

            // pageSize: ???
            // page: ???
        }
}

// TODO: Better code examples in setting dialogs
// Example stuff
class TypeWithOptionalProperty
{
    key id: ID

    // Optional/nullable property
    value: String?
}

// Draft meta-model
class Class
{
    key name: String
}

enumeration DataType
{
    ID,
    Boolean,
    Integer,
    Double,
    Float,
    Long,
    String,
    Instant,
    LocalDate,
}

enumeration Multiplicity
{
    ZERO_TO_ONE,
    ONE_TO_ONE,
    ZERO_TO_MANY,
    ONE_TO_MANY,
}

class DataTypeProperty
{
    key className: String
    key name: String
    dataType: DataType
    optional: Boolean

    // key is a keyword, needs backticks to use as identifier
    `key`: Boolean
}

association ClassHasDataTypeProperties
{
    class: Class[1..1]
    dataTypeProperties: DataTypeProperty[0..*]

    relationship Class.name == DataTypeProperty.className
}

class Enumeration
{
    key name: String
}

class EnumerationLiteral
{
    key enumerationName: String
    key name: String
}

association EnumerationHasLiterals
{
    enumeration: Enumeration[1..1]
    enumerationLiterals: EnumerationLiteral[1..*]

    relationship Enumeration.name == EnumerationLiteral.enumerationName
}

class EnumerationProperty
{
    key className: String
    key name: String
    optional: Boolean
    `key`: Boolean
    private enumerationName: String
}

association EnumerationPropertyHasEnumeration
{
    enumerationProperty: EnumerationProperty[0..*]
    enumeration: Enumeration[1..1]

    relationship EnumerationProperty.enumerationName == Enumeration.name
}

association ClassHasEnumerationProperties
{
    class: Class[1..1]
    enumerationProperties: EnumerationProperty[0..*]

    relationship Class.name == EnumerationProperty.className
}

enumeration AssociationEndDirection
{
    SOURCE("source"),
    TARGET("target"),
}

class Association
{
    key name: String

    source(): AssociationEnd[1..1]
    {
        this.name == AssociationEnd.associationName
            && AssociationEnd.direction == AssociationEndDirection.SOURCE
    }

    target(): AssociationEnd[1..1]
    {
        this.name == AssociationEnd.associationName
            && AssociationEnd.direction == AssociationEndDirection.TARGET
    }
}

class AssociationEnd
{
    name: String
    key associationName: String
    key direction: AssociationEndDirection
    multiplicity: Multiplicity
}

// simplification, ideally we'd model an association as having exactly two ends
association AssociationHasEnds
{
    association: Association[1..1]
    owned associationEnds: AssociationEnd[0..*]

    relationship Association.name == AssociationEnd.associationName
}

association AssociationEndHasResultTypeClass
{
    associationEndsResultTypeOf: AssociationEnd[0..*]
    resultType: Class[1..1]
}

association ClassHasAssociationEnds
{
    owningType: Class[1..1]
    associationEnds: AssociationEnd[0..*]
}

class ParameterizedProperty
{
    key owningClassName: String
    key name: String
    optional: Boolean
    `key`: Boolean
    private resultTypeName: String
}

association ClassHasParameterizedProperties
{
    owningType: Class[1..1]
    owned parameterizedProperties: ParameterizedProperty[0..*]

    relationship Class.name == ParameterizedProperty.owningClassName
}

association ParameterizedPropertyHasResultType
{
    parameterizedProperty: ParameterizedProperty[0..*]
    resultType: Class[1..1]

    relationship ParameterizedProperty.resultTypeName == Class.name
}

class AssociationEndOrderBy
{
    private key associationName: String
    name: String
    multiplicity: Multiplicity
    key direction: AssociationEndDirection
    private orderById: Long
}

class ParameterizedPropertyOrderBy
{
    private key owningClassName: String
    key name: String
    private orderById: Long
}

association AssociationEndHasOrderBy
{
    associationEnd: AssociationEnd[1..1]
    associationEndOrderBy: AssociationEndOrderBy[0..1]

    relationship AssociationEnd.associationName == AssociationEndOrderBy.associationName
            && AssociationEnd.direction == AssociationEndOrderBy.direction
}

association ParameterizedPropertyHasOrderBy
{
    parameterizedProperty: ParameterizedProperty[1..1]
    parameterizedPropertyOrderBy: ParameterizedPropertyOrderBy[0..1]

    relationship ParameterizedProperty.owningClassName == ParameterizedPropertyOrderBy.owningClassName
            && ParameterizedProperty.name == ParameterizedPropertyOrderBy.name
}

association AssociationEndOrderByHasParts
{
    associationEndOrderBy: AssociationEndOrderBy[1..1]
    orderBy: OrderBy[1..*]

    relationship AssociationEndOrderBy.orderById == OrderBy.id
}

association ParameterizedPropertyOrderByHasParts
{
    parameterizedPropertyOrderBy: ParameterizedPropertyOrderBy[1..1]
    orderBy: OrderBy[1..*]

    relationship ParameterizedPropertyOrderBy.orderById == OrderBy.id
}

class OrderBy
{
    key id: ID
}

// Split into data type / enum type order bys?
class OrderByPart
{
    key orderById: Long

    // TODO: order keyword for properties meant for sorting?
    key ordinal: Integer
    private className: String
    private propertyName: String
    direction: OrderByDirection
}

association OrderByHasParts
{
    orderBy: OrderBy[1..1]
    orderByParts: OrderByPart[1..*]
        orderBy: this.ordinal

    relationship OrderBy.id == OrderByPart.orderById
}

enumeration OrderByDirection
{
    ASCENDING("ascending"),
    DESCENDING("descending"),
}

association OrderByPartHasDataTypeProperty
{
    orderByPart: OrderByPart[0..*]
    dataTypeProperty: DataTypeProperty[1..1]

    relationship OrderByPart.className == DataTypeProperty.className
            && OrderByPart.propertyName == DataTypeProperty.name
}

association OrderByPartHasEnumerationProperty
{
    orderByPart: OrderByPart[0..*]
    enumerationProperty: EnumerationProperty[1..1]

    relationship OrderByPart.className == EnumerationProperty.className
            && OrderByPart.propertyName == EnumerationProperty.name
}

association ParameterizedPropertyHasParameters
{
    parameterizedProperty: ParameterizedProperty[1..1]
    parameters: Parameter[0..*]
}

class Parameter
{
}

/*
association ParameterizedPropertyHasCriteria
{

}
*/

class Package
{
    key id: ID
    name: String
    private parentId: Long?
}

association PackageHasChildPackages
{
    package: Package[0..1]
    childPackages: Package[0..*]

    relationship this.id == Package.parentId
}

association PackageHasClasses
{
    package: Package[1..1]
    classes: Class[0..*]
}

association PackageHasEnumerations
{
    package: Package[1..1]
    enumerations: Enumeration[0..*]
}

association PackageHasAssociations
{
    package: Package[1..1]
    associations: Association[0..*]
}
