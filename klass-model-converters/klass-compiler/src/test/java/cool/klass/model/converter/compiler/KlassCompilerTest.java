package cool.klass.model.converter.compiler;

import java.util.Optional;

import javax.annotation.Nonnull;

import cool.klass.model.converter.compiler.error.RootCompilerError;
import cool.klass.model.meta.domain.api.DomainModel;
import cool.klass.test.constants.KlassTestConstants;
import org.apache.commons.text.StringEscapeUtils;
import org.eclipse.collections.api.list.ImmutableList;
import org.junit.Test;

import static org.hamcrest.CoreMatchers.notNullValue;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.fail;

public class KlassCompilerTest
{
    @Test
    public void stackOverflow()
    {
        this.assertNoCompilerErrors(KlassTestConstants.STACK_OVERFLOW_SOURCE_CODE_TEXT);
    }

    @Test
    public void meta()
    {
        //<editor-fold desc="source code">
        //language=Klass
        String sourceCodeText = ""
                + "package klass.model.meta.domain\n"
                + "\n"
                + "interface Element\n"
                + "{\n"
                + "    inferred: Boolean;\n"
                + "    sourceCode: String;\n"
                + "    sourceCodeWithInference: String;\n"
                + "}\n"
                + "\n"
                + "interface NamedElement\n"
                + "    implements Element\n"
                + "{\n"
                + "    name: String;\n"
                + "    ordinal: Integer;\n"
                + "}\n"
                + "\n"
                + "interface PackageableElement\n"
                + "{\n"
                + "    packageName: String;\n"
                + "    // fullyQualifiedName: String = packageName + \".\" + name;\n"
                + "}\n"
                + "\n"
                + "class Classifier\n"
                + "    abstract\n"
                + "    implements PackageableElement\n"
                + "    transient\n"
                + "{\n"
                + "    name: String key;\n"
                + "    inferred: Boolean;\n"
                + "    packageName: String;\n"
                + "\n"
                + "    // TODO: Ordinals should have a syntax and be inferred using macros\n"
                + "    ordinal: Integer;\n"
                + "    sourceCode: String;\n"
                + "}\n"
                + "\n"
                + "// TODO: Error when transient extends non-transient\n"
                + "class Interface\n"
                + "    extends Classifier\n"
                + "    transient\n"
                + "{\n"
                + "}\n"
                + "\n"
                + "class ClassifierInterfaceMapping\n"
                + "{\n"
                + "    classifierName: String key private;\n"
                + "    interfaceName: String key private;\n"
                + "}\n"
                + "\n"
                + "association ClassifierHasClassifierInterfaceMapping\n"
                + "{\n"
                + "    subClassifier: Classifier[1..1];\n"
                + "    superInterfaces: ClassifierInterfaceMapping[0..*] owned;\n"
                + "\n"
                + "    relationship this.name == ClassifierInterfaceMapping.classifierName\n"
                + "}\n"
                + "\n"
                + "association ClassifierInterfaceMappingHasInterface\n"
                + "{\n"
                + "    superInterface: Interface[1..1];\n"
                + "    subClassifiers: ClassifierInterfaceMapping[0..*];\n"
                + "\n"
                + "    relationship this.name == ClassifierInterfaceMapping.interfaceName\n"
                + "}\n"
                + "\n"
                + "class Class\n"
                + "    extends Classifier\n"
                + "    transient\n"
                + "{\n"
                + "    superClassName: String? private;\n"
                + "}\n"
                + "\n"
                + "association ClassHasSuperClass\n"
                + "{\n"
                + "    subClasses: Class[0..*];\n"
                + "    superClass: Class[0..1];\n"
                + "\n"
                + "    relationship this.superClassName == Class.name\n"
                + "}\n"
                + "\n"
                + "enumeration PrimitiveType\n"
                + "{\n"
                + "    INTEGER(\"Integer\"),\n"
                + "    LONG(\"Long\"),\n"
                + "    DOUBLE(\"Double\"),\n"
                + "    FLOAT(\"Float\"),\n"
                + "    BOOLEAN(\"Boolean\"),\n"
                + "    STRING(\"String\"),\n"
                + "    INSTANT(\"Instant\"),\n"
                + "    LOCAL_DATE(\"LocalDate\"),\n"
                + "    TEMPORAL_INSTANT(\"TemporalInstant\"),\n"
                + "    TEMPORAL_RANGE(\"TemporalRange\"),\n"
                + "}\n"
                + "\n"
                + "enumeration Multiplicity\n"
                + "{\n"
                + "    ZERO_TO_ONE(\"0..1\"),\n"
                + "    ONE_TO_ONE(\"1..1\"),\n"
                + "    ZERO_TO_MANY(\"0..*\"),\n"
                + "    ONE_TO_MANY(\"1..*\"),\n"
                + "}\n"
                + "\n"
                + "class PrimitiveProperty\n"
                + "    transient\n"
                + "{\n"
                + "    className                     : String key;\n"
                + "    name                          : String key;\n"
                + "    inferred                      : Boolean;\n"
                + "    primitiveType                 : PrimitiveType;\n"
                + "    optional                      : Boolean;\n"
                + "    key                           : Boolean;\n"
                + "    id                            : Boolean;\n"
                + "    ordinal                       : Integer;\n"
                + "}\n"
                + "\n"
                + "association ClassHasPrimitiveTypeProperties\n"
                + "{\n"
                + "    owningClass: Class[1..1];\n"
                + "    primitiveProperties: PrimitiveProperty[0..*] owned\n"
                + "    // TODO: Change the orderBy syntax to orderBy(this.ordinal)\n"
                + "        orderBy: this.ordinal;\n"
                + "\n"
                + "    relationship this.name == PrimitiveProperty.className\n"
                + "}\n"
                + "\n"
                + "class Enumeration\n"
                + "    transient\n"
                + "{\n"
                + "    name                          : String key;\n"
                + "    inferred                      : Boolean;\n"
                + "    packageName                   : String private;\n"
                + "    ordinal                       : Integer;\n"
                + "    sourceCode                    : String;\n"
                + "}\n"
                + "\n"
                + "class EnumerationLiteral\n"
                + "    transient\n"
                + "{\n"
                + "    enumerationName               : String key;\n"
                + "    name                          : String key;\n"
                + "    inferred                      : Boolean;\n"
                + "    prettyName                    : String;\n"
                + "    ordinal                       : Integer;\n"
                + "}\n"
                + "\n"
                + "association EnumerationHasLiterals\n"
                + "{\n"
                + "    enumeration: Enumeration[1..1];\n"
                + "    enumerationLiterals: EnumerationLiteral[1..*]\n"
                + "        orderBy: this.ordinal;\n"
                + "\n"
                + "    relationship this.name == EnumerationLiteral.enumerationName\n"
                + "}\n"
                + "\n"
                + "class EnumerationProperty\n"
                + "    transient\n"
                + "{\n"
                + "    className                     : String key;\n"
                + "    name                          : String key;\n"
                + "    inferred                      : Boolean;\n"
                + "    enumerationName               : String private;\n"
                + "    optional                      : Boolean;\n"
                + "    key                           : Boolean;\n"
                + "    ordinal                       : Integer;\n"
                + "}\n"
                + "\n"
                + "association EnumerationPropertyHasEnumeration\n"
                + "{\n"
                + "    enumerationProperty: EnumerationProperty[0..*];\n"
                + "    enumeration: Enumeration[1..1];\n"
                + "\n"
                + "    relationship this.enumerationName == Enumeration.name\n"
                + "}\n"
                + "\n"
                + "association ClassHasEnumerationProperties\n"
                + "{\n"
                + "    owningClass: Class[1..1];\n"
                + "    enumerationProperties: EnumerationProperty[0..*]\n"
                + "        orderBy: this.ordinal;\n"
                + "\n"
                + "    relationship this.name == EnumerationProperty.className\n"
                + "}\n"
                + "\n"
                + "class PrimitivePropertyModifier\n"
                + "    transient\n"
                + "{\n"
                + "    className                     : String key;\n"
                + "    propertyName                  : String key;\n"
                + "    name                          : String key;\n"
                + "    inferred                      : Boolean;\n"
                + "    ordinal                       : Integer;\n"
                + "}\n"
                + "\n"
                + "class EnumerationPropertyModifier\n"
                + "    transient\n"
                + "{\n"
                + "    className                     : String key;\n"
                + "    propertyName                  : String key;\n"
                + "    name                          : String key;\n"
                + "    inferred                      : Boolean;\n"
                + "    ordinal                       : Integer;\n"
                + "}\n"
                + "\n"
                + "association PrimitivePropertyHasModifiers\n"
                + "{\n"
                + "    primitiveProperty: PrimitiveProperty[1..1];\n"
                + "    primitivePropertyModifiers: PrimitivePropertyModifier[0..*]\n"
                + "        orderBy: this.ordinal;\n"
                + "\n"
                + "    relationship this.className == PrimitivePropertyModifier.className\n"
                + "            && this.name == PrimitivePropertyModifier.propertyName\n"
                + "}\n"
                + "\n"
                + "association EnumerationPropertyHasModifiers\n"
                + "{\n"
                + "    enumerationProperty: EnumerationProperty[1..1];\n"
                + "    enumerationPropertyModifiers: EnumerationPropertyModifier[0..*]\n"
                + "        orderBy: this.ordinal;\n"
                + "\n"
                + "    relationship this.className == EnumerationPropertyModifier.className\n"
                + "            && this.name == EnumerationPropertyModifier.propertyName\n"
                + "}\n"
                + "\n"
                + "class ClassModifier\n"
                + "    transient\n"
                + "{\n"
                + "    className                     : String key;\n"
                + "    name                          : String key;\n"
                + "    inferred                      : Boolean;\n"
                + "    ordinal                       : Integer;\n"
                + "}\n"
                + "\n"
                + "association ClassHasModifiers\n"
                + "{\n"
                + "    owningClass: Class[1..1];\n"
                + "    classModifiers: ClassModifier[0..*]\n"
                + "        orderBy: this.ordinal;\n"
                + "\n"
                + "    relationship this.name == ClassModifier.className\n"
                + "}\n"
                + "\n"
                + "enumeration AssociationEndDirection\n"
                + "{\n"
                + "    SOURCE(\"source\"),\n"
                + "    TARGET(\"target\"),\n"
                + "}\n"
                + "\n"
                + "class Association\n"
                + "    transient\n"
                + "{\n"
                + "    name                          : String key;\n"
                + "    inferred                      : Boolean;\n"
                + "    packageName                   : String;\n"
                + "    ordinal                       : Integer;\n"
                + "    sourceCode                    : String;\n"
                + "\n"
                + "    source(): AssociationEnd[1..1]\n"
                + "    {\n"
                + "        this.name == AssociationEnd.associationName\n"
                + "            && AssociationEnd.direction == AssociationEndDirection.SOURCE\n"
                + "    }\n"
                + "\n"
                + "    target(): AssociationEnd[1..1]\n"
                + "    {\n"
                + "        this.name == AssociationEnd.associationName\n"
                + "            && AssociationEnd.direction == AssociationEndDirection.TARGET\n"
                + "    }\n"
                + "}\n"
                + "\n"
                + "class AssociationEnd\n"
                + "    transient\n"
                + "{\n"
                + "    owningClassName               : String key private;\n"
                + "    name                          : String key;\n"
                + "    inferred                      : Boolean;\n"
                + "    associationName               : String;\n"
                + "    direction                     : AssociationEndDirection;\n"
                + "    multiplicity                  : Multiplicity;\n"
                + "    resultTypeName                : String private;\n"
                + "    ordinal                       : Integer;\n"
                + "}\n"
                + "\n"
                + "// simplification, ideally we'd model an association as having exactly two ends\n"
                + "association AssociationHasEnds\n"
                + "{\n"
                + "    owningAssociation: Association[1..1];\n"
                + "    associationEnds: AssociationEnd[0..*]\n"
                + "        orderBy: this.direction;\n"
                + "\n"
                + "    relationship this.name == AssociationEnd.associationName\n"
                + "}\n"
                + "\n"
                + "association ClassHasAssociationEnds\n"
                + "{\n"
                + "    owningClass: Class[1..1];\n"
                + "    associationEnds: AssociationEnd[0..*];\n"
                + "    // TODO: Order by this.owningAssociation.ordinal\n"
                + "\n"
                + "    relationship this.name == AssociationEnd.owningClassName\n"
                + "}\n"
                + "\n"
                + "association AssociationEndHasResultType\n"
                + "{\n"
                + "    associationEndsResultTypeOf: AssociationEnd[0..*];\n"
                + "    resultType: Class[1..1];\n"
                + "\n"
                + "    relationship this.resultTypeName == Class.name\n"
                + "}\n"
                + "\n"
                + "class AssociationEndModifier\n"
                + "    transient\n"
                + "{\n"
                + "    owningClassName               : String key;\n"
                + "    associationEndName            : String key;\n"
                + "    name                          : String key;\n"
                + "    inferred                      : Boolean;\n"
                + "    ordinal                       : Integer;\n"
                + "}\n"
                + "\n"
                + "association AssociationEndHasModifiers\n"
                + "{\n"
                + "    associationEnd: AssociationEnd[1..1];\n"
                + "    associationEndModifiers: AssociationEndModifier[0..*]\n"
                + "        orderBy: this.ordinal;\n"
                + "\n"
                + "    relationship this.owningClassName == AssociationEndModifier.owningClassName\n"
                + "            && this.name == AssociationEndModifier.associationEndName\n"
                + "}\n"
                + "\n"
                + "class ParameterizedProperty\n"
                + "    transient\n"
                + "{\n"
                + "    owningClassName               : String key private;\n"
                + "    name                          : String key;\n"
                + "    inferred                      : Boolean;\n"
                + "    multiplicity                  : Multiplicity;\n"
                + "    resultTypeName                : String private;\n"
                + "    ordinal                       : Integer;\n"
                + "}\n"
                + "\n"
                + "association ClassHasParameterizedProperties\n"
                + "{\n"
                + "    owningClass: Class[1..1];\n"
                + "    parameterizedProperties: ParameterizedProperty[0..*] owned\n"
                + "        orderBy: this.ordinal;\n"
                + "\n"
                + "    relationship this.name == ParameterizedProperty.owningClassName\n"
                + "}\n"
                + "\n"
                + "association ParameterizedPropertyHasResultType\n"
                + "{\n"
                + "    parameterizedPropertiesResultTypeOf: ParameterizedProperty[0..*];\n"
                + "    resultType: Class[1..1];\n"
                + "\n"
                + "    relationship this.resultTypeName == Class.name\n"
                + "}\n"
                + "\n"
                + "class AssociationEndOrdering\n"
                + "    transient\n"
                + "{\n"
                + "    associationName               : String key private;\n"
                + "    name                          : String;\n"
                + "    inferred                      : Boolean;\n"
                + "    multiplicity                  : Multiplicity;\n"
                + "    direction                     : AssociationEndDirection key;\n"
                + "    orderingId                    : Long private;\n"
                + "}\n"
                + "\n"
                + "class ParameterizedPropertyOrdering\n"
                + "    transient\n"
                + "{\n"
                + "    owningClassName               : String private key;\n"
                + "    name                          : String key;\n"
                + "    inferred                      : Boolean;\n"
                + "    orderingId                    : Long private;\n"
                + "}\n"
                + "\n"
                + "association AssociationEndHasOrdering\n"
                + "{\n"
                + "    associationEnd: AssociationEnd[1..1];\n"
                + "    associationEndOrdering: AssociationEndOrdering[0..1] owned;\n"
                + "\n"
                + "    relationship this.associationName == AssociationEndOrdering.associationName\n"
                + "            && this.direction == AssociationEndOrdering.direction\n"
                + "}\n"
                + "\n"
                + "association ParameterizedPropertyHasOrdering\n"
                + "{\n"
                + "    parameterizedProperty: ParameterizedProperty[1..1];\n"
                + "    parameterizedPropertyOrdering: ParameterizedPropertyOrdering[0..*];\n"
                + "\n"
                + "    relationship this.owningClassName == ParameterizedPropertyOrdering.owningClassName\n"
                + "            && this.name == ParameterizedPropertyOrdering.name\n"
                + "}\n"
                + "\n"
                + "/*\n"
                + "association AssociationEndOrderingHasParts\n"
                + "{\n"
                + "    associationEndOrdering: AssociationEndOrdering[1..1];\n"
                + "    ordering: Ordering[1..*];\n"
                + "\n"
                + "    relationship this.orderingId == Ordering.id\n"
                + "}\n"
                + "\n"
                + "association ParameterizedPropertyOrderingHasParts\n"
                + "{\n"
                + "    parameterizedPropertyOrdering: ParameterizedPropertyOrdering[1..1] owned;\n"
                + "    ordering: Ordering[1..1];\n"
                + "\n"
                + "    // TODO: error when there's no \"this\"\n"
                + "    // relationship ParameterizedPropertyOrdering.orderingId == Ordering.id\n"
                + "    // TODO: error when the foreign key for a to-many is its entire primary key\n"
                + "    // relationship ParameterizedPropertyOrdering.orderingId == Ordering.id\n"
                + "    relationship this.orderingId == Ordering.id\n"
                + "}\n"
                + "\n"
                + "class Ordering\n"
                + "    transient\n"
                + "{\n"
                + "    id                            : Long id key;\n"
                + "    inferred                      : Boolean;\n"
                + "}\n"
                + "\n"
                + "// Split into data type / enum type order bys?\n"
                + "class OrderingPart\n"
                + "    transient\n"
                + "{\n"
                + "    orderingId                    : Long key;\n"
                + "    inferred                      : Boolean;\n"
                + "\n"
                + "    // TODO: order keyword for properties meant for sorting?\n"
                + "    ordinal                       : Integer key;\n"
                + "    className                     : String private;\n"
                + "    propertyName                  : String private;\n"
                + "    direction                     : OrderingDirection;\n"
                + "}\n"
                + "\n"
                + "association OrderingHasParts\n"
                + "{\n"
                + "    ordering: Ordering[1..1];\n"
                + "    orderingParts: OrderingPart[1..*]\n"
                + "        orderBy: this.ordinal;\n"
                + "\n"
                + "    relationship this.id == OrderingPart.orderingId\n"
                + "}\n"
                + "\n"
                + "enumeration OrderingDirection\n"
                + "{\n"
                + "    ASCENDING(\"ascending\"),\n"
                + "    DESCENDING(\"descending\"),\n"
                + "}\n"
                + "\n"
                + "association OrderingPartHasDataTypeProperty\n"
                + "{\n"
                + "    orderingParts: OrderingPart[0..*];\n"
                + "    dataTypeProperty: PrimitiveProperty[1..1];\n"
                + "\n"
                + "    relationship this.className == PrimitiveProperty.className\n"
                + "            && this.propertyName == PrimitiveProperty.name\n"
                + "}\n"
                + "\n"
                + "association OrderingPartHasEnumerationProperty\n"
                + "{\n"
                + "    orderingParts: OrderingPart[0..*];\n"
                + "    enumerationProperty: EnumerationProperty[1..1];\n"
                + "\n"
                + "    relationship this.className == EnumerationProperty.className\n"
                + "            && this.propertyName == EnumerationProperty.name\n"
                + "}\n"
                + "*/\n"
                + "\n"
                + "association ParameterizedPropertyHasParameters\n"
                + "{\n"
                + "    parameterizedProperty: ParameterizedProperty[1..1];\n"
                + "    parameters: ParameterizedPropertyParameter[0..*];\n"
                + "\n"
                + "    relationship this.owningClassName == ParameterizedPropertyParameter.parameterizedPropertyClassName\n"
                + "            && this.name == ParameterizedPropertyParameter.parameterizedPropertyName\n"
                + "}\n"
                + "\n"
                + "class ParameterizedPropertyParameter\n"
                + "    transient\n"
                + "{\n"
                + "    parameterizedPropertyClassName: String key private;\n"
                + "    parameterizedPropertyName     : String key;\n"
                + "    name                          : String;\n"
                + "    inferred                      : Boolean;\n"
                + "}\n"
                + "\n"
                + "/*\n"
                + "association ParameterizedPropertyHasCriteria\n"
                + "{\n"
                + "\n"
                + "}\n"
                + "*/\n"
                + "\n"
                + "enumeration ServiceMultiplicity\n"
                + "{\n"
                + "    ONE,\n"
                + "    MANY,\n"
                + "}\n"
                + "\n"
                + "enumeration Verb\n"
                + "{\n"
                + "    GET,\n"
                + "    POST,\n"
                + "    PUT,\n"
                + "    PATCH,\n"
                + "    DELETE,\n"
                + "}\n"
                + "\n"
                + "class Service\n"
                + "    transient\n"
                + "{\n"
                + "    className          : String key;\n"
                + "    urlString          : String key;\n"
                + "    verb               : Verb key;\n"
                + "    serviceMultiplicity: ServiceMultiplicity;\n"
                + "}\n"
                + "\n"
                + "class Url\n"
                + "    transient\n"
                + "{\n"
                + "    className          : String key;\n"
                + "    url                : String key;\n"
                + "}\n"
                + "\n"
                + "class ServiceGroup\n"
                + "    transient\n"
                + "{\n"
                + "    className          : String key;\n"
                + "}\n"
                + "\n"
                + "association ServiceGroupHasClass\n"
                + "{\n"
                + "    serviceGroup: ServiceGroup[0..1];\n"
                + "    owningClass: Class[1..1];\n"
                + "\n"
                + "    relationship this.className == Class.name\n"
                + "}\n"
                + "\n"
                + "association ServiceGroupHasUrls\n"
                + "{\n"
                + "    serviceGroup: ServiceGroup[1..1];\n"
                + "    urls: Url[1..*];\n"
                + "\n"
                + "    relationship this.className == Url.className\n"
                + "}\n"
                + "\n"
                + "association UrlHasServices\n"
                + "{\n"
                + "    url: Url[1..1];\n"
                + "    services: Service[1..*];\n"
                + "\n"
                + "    relationship this.className == Service.className && this.url == Service.urlString\n"
                + "}\n"
                + "\n"
                + "projection ClassReadProjection on Class\n"
                + "{\n"
                + "    name                 : \"Class name\",\n"
                + "    inferred             : \"Class inferred\",\n"
                + "    packageName          : \"Class package name\",\n"
                + "    ordinal              : \"Class ordinal\",\n"
                + "    sourceCode           : \"Class source code\",\n"
                + "    superClass           :\n"
                + "    {\n"
                + "        name       : \"Super Class name\",\n"
                + "        packageName: \"Super Class package name\",\n"
                + "    },\n"
                + "    // TODO: flat many-to-many, or parameterized property\n"
                + "    superInterfaces      :\n"
                + "    {\n"
                + "        superInterface:\n"
                + "        {\n"
                + "            name       : \"Class name\",\n"
                + "            packageName: \"Class package name\",\n"
                + "        },\n"
                + "    },\n"
                + "    classModifiers       :\n"
                + "    {\n"
                + "        name    : \"Class modifier name\",\n"
                + "        inferred: \"Class modifier inferred\",\n"
                + "        ordinal : \"Class modifier ordinal\",\n"
                + "    },\n"
                + "    primitiveProperties  :\n"
                + "    {\n"
                + "        name                      : \"Primitive property name\",\n"
                + "        inferred                  : \"Primitive property inferred\",\n"
                + "        primitiveType             : \"Primitive property type\",\n"
                + "        optional                  : \"Primitive property is optional\",\n"
                + "        key                       : \"Primitive property is key\",\n"
                + "        id                        : \"Primitive property is id\",\n"
                + "        ordinal                   : \"Primitive property ordinal\",\n"
                + "        primitivePropertyModifiers:\n"
                + "        {\n"
                + "            name    : \"Primitive property modifier name\",\n"
                + "            inferred: \"Primitive property modifier inferred\",\n"
                + "            ordinal : \"Primitive property modifier ordinal\",\n"
                + "        },\n"
                + "    },\n"
                + "    enumerationProperties:\n"
                + "    {\n"
                + "        name                        : \"Enumeration property name\",\n"
                + "        inferred                    : \"Enumeration property inferred\",\n"
                + "        optional                    : \"Enumeration property is optional\",\n"
                + "        key                         : \"Enumeration property is key\",\n"
                + "        ordinal                     : \"Enumeration property ordinal\",\n"
                + "        enumeration                 :\n"
                + "        {\n"
                + "            name    : \"Enumeration name\",\n"
                + "            inferred: \"Enumeration inferred\",\n"
                + "        },\n"
                + "        enumerationPropertyModifiers:\n"
                + "        {\n"
                + "            name    : \"Enumeration property modifier name\",\n"
                + "            inferred: \"Enumeration property inferred\",\n"
                + "            ordinal : \"Enumeration property modifier ordinal\",\n"
                + "        },\n"
                + "    },\n"
                + "    associationEnds      :\n"
                + "    {\n"
                + "        name                   : \"Association end name\",\n"
                + "        inferred               : \"Association end inferred\",\n"
                + "        direction              : \"Association end direction\",\n"
                + "        multiplicity           : \"Association end multiplicity\",\n"
                + "        resultType             :\n"
                + "        {\n"
                + "            name: \"Association end result type name\",\n"
                + "        },\n"
                + "        owningAssociation      :\n"
                + "        {\n"
                + "            name: \"Association end owning association name\",\n"
                + "        },\n"
                + "        associationEndModifiers:\n"
                + "        {\n"
                + "            name    : \"Association end modifier name\",\n"
                + "            inferred: \"Association end modifier inferred\",\n"
                + "            ordinal : \"Association end modifier ordinal\",\n"
                + "        },\n"
                + "    },\n"
                + "}\n"
                + "\n"
                + "service Class\n"
                + "{\n"
                + "    /meta/class/{className: String[1..1]}\n"
                + "        GET\n"
                + "        {\n"
                + "            multiplicity: one;\n"
                + "            criteria    : this.name == className;\n"
                + "            projection  : ClassReadProjection;\n"
                + "        }\n"
                + "    /meta/class\n"
                + "        GET\n"
                + "        {\n"
                + "            multiplicity: many;\n"
                + "            criteria    : all;\n"
                + "            projection  : ClassReadProjection;\n"
                + "        }\n"
                + "}\n"
                + "\n"
                + "projection AssociationReadProjection on Association\n"
                + "{\n"
                + "    name           : \"Association name\",\n"
                + "    inferred       : \"Association inferred\",\n"
                + "    packageName    : \"Association package name\",\n"
                + "    ordinal        : \"Association ordinal\",\n"
                + "    sourceCode     : \"Association source code\",\n"
                + "    associationEnds:\n"
                + "    {\n"
                + "        name        : \"Association end name\",\n"
                + "        inferred    : \"Association end inferred\",\n"
                + "        direction   : \"Association end direction\",\n"
                + "        multiplicity: \"Association end multiplicity\",\n"
                + "        ordinal     : \"Association end ordinal\",\n"
                + "        /*\n"
                + "        owningClass :\n"
                + "        {\n"
                + "            name       : \"Association end owning class name\",\n"
                + "            packageName: \"Association end owning class package name\",\n"
                + "        },\n"
                + "        */\n"
                + "        resultType  :\n"
                + "        {\n"
                + "            name       : \"Association end result class name\",\n"
                + "            packageName: \"Association end result class package name\",\n"
                + "        },\n"
                + "    },\n"
                + "}\n"
                + "\n"
                + "service Association\n"
                + "{\n"
                + "    /meta/association/{associationName: String[1..1]}\n"
                + "        GET\n"
                + "        {\n"
                + "            multiplicity: one;\n"
                + "            criteria    : this.name == associationName;\n"
                + "            projection  : AssociationReadProjection;\n"
                + "        }\n"
                + "    /meta/association\n"
                + "        GET\n"
                + "        {\n"
                + "            multiplicity: many;\n"
                + "            criteria    : all;\n"
                + "            projection  : AssociationReadProjection;\n"
                + "        }\n"
                + "}\n";
        //</editor-fold>

        this.assertNoCompilerErrors(sourceCodeText);
    }

    @Test
    public void emoji()
    {
        //<editor-fold desc="source code">
        //language=Klass
        String sourceCodeText = ""
                + "package com.emoji\n"
                + "\n"
                + "// 😃\n";
        //</editor-fold>

        this.assertNoCompilerErrors(sourceCodeText);
    }

    @Nonnull
    private String compilerErrorSourceCode(String compilerError)
    {
        return "                \"\"\n"
                + "                        + \"" + this.wrapSourceCode(compilerError) + "\",\n";
    }

    @Nonnull
    private String wrapSourceCode(String unwrappedSourceCode)
    {
        // https://stackoverflow.com/questions/11125459/java-regex-negative-lookahead
        return StringEscapeUtils.escapeJava(unwrappedSourceCode)
                .replaceAll("\\\\n(?!$)", "\\\\n\"\n                        + \"");
    }

    private void assertNoCompilerErrors(@Nonnull String sourceCodeText)
    {
        CompilationUnit compilationUnit = CompilationUnit.createFromText(
                Optional.empty(),
                "example.klass",
                sourceCodeText);
        CompilerState     compilerState     = new CompilerState(compilationUnit);
        KlassCompiler     compiler          = new KlassCompiler(compilerState);
        CompilationResult compilationResult = compiler.compile();
        if (compilationResult instanceof ErrorsCompilationResult)
        {
            ErrorsCompilationResult          errorsCompilationResult = (ErrorsCompilationResult) compilationResult;
            ImmutableList<RootCompilerError> compilerErrors          = errorsCompilationResult.getCompilerErrors();
            String                           message                 = compilerErrors.makeString("\n");
            fail(message);
        }
        else if (compilationResult instanceof DomainModelCompilationResult)
        {
            DomainModelCompilationResult domainModelCompilationResult = (DomainModelCompilationResult) compilationResult;
            DomainModel                  domainModel                  = domainModelCompilationResult.getDomainModel();
            assertThat(domainModel, notNullValue());
        }
        else
        {
            fail(compilationResult.getClass().getSimpleName());
        }
    }
}
